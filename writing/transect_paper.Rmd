---
title: "A Tale of Two Transects"
subtitle: "Also Two Sequencing Technologies, and Two Amplicons"
author: 
  - Brendan Furneaux^1^,
    Mohammad Bahram^1^,
    Anna Rosling^3^,
    Nourou S. Yorou^2^,
    Martin Ryberg^1^
  - ^1^Program in Systematic Biology,
    Department of Organismal Biology,
    Uppsala University,
    Uppsala, Sweden
  - ^2^Research Unit in Tropical Mycology and Plant-Fungi Interactions,
    LEB,
    University of Parakou,
    Parakou, Benin
  - ^3^Program in Evolutionary Biology,
    Department of Ecology and Genetics,
    Uppsala University,
    Uppsala, Sweden
date: "`r format(Sys.time(), '%B %d, %Y')`"
bibliography:
  - "all.bib"
  - "R.bib"
csl: molecular-ecology.csl
output:
  bookdown::pdf_document2:
    fig_crop: yes
    keep_tex: yes
    latex_engine: lualatex
    includes:
      in_header: preamble.tex
  bookdown::word_document2: 
    keep_md: yes
---

```{r setup, include=FALSE}
library("knitr")
library("tikzDevice")
library("ggplot2")
library("magrittr")
library("tidyverse")
library("drake")
library("here")
library("phyloseq")
tryCatch(
  tinytex::tinytex_root(),
  error = function(e) tinytex::install_tinytex()
  )
knitr::opts_chunk$set(
  dev = "pdf",
  # dev.args = list(pointsize=32),
  echo = FALSE,
  # results = 'asis',
  # fig.show = 'asis',
  fig.width = 6,
  fig.height = 4.5,
  message = FALSE,
  warning = FALSE,
  external = TRUE
)
options(
  tikzDefaultEngine = "luatex",
  tikzXelatexPackages = c(options("tikzXelatexPackages")$tikzXelatexPackages,
                          "\\usepackage[version=4]{mhchem}\n",
                          "\\usepackage{siunitx}\n",
                          "\\DeclareSIUnit\\year{a}\n",
                          "\\usepackage{fontspec}"),
  tikzMetricsDictionary = here("writing/transect_paper-tikzDictionary")
)

base.dir <- regmatches(getwd(), regexpr(".*oueme-fungi-transect", getwd()))
if (opts_chunk$get("dev") == "tikz") {
  # styles$Expression <- styles$LaTeX.Expression
  # styles$Name <- styles$LaTeX.Name
  # styles$Short.Name <- styles$LaTeX.Short.Name
  # styles$Unit <- paste0("\\si{", styles$LaTeX.Unit, "}")
}
write_bib(c("base", "phyloseq", "gstat"), file = "R.bib", tweak = TRUE)
cache = drake_cache(here(".light"))
light_plan <- readRDS(here("data/plan/drake_light.rds"))
theme_set(theme_bw())

datasets <- read_csv(here("config/datasets.csv"), col_types = "cccccccicccccicc")
regions <- read_csv(here("config/regions.csv"), col_types = "cccciiiiic")

reads_table <- cache$list() %>%
  purrr::keep(startsWith, "big_seq_table_") %>%
  purrr::map(readd, character_only = TRUE, cache = cache) %>%
  purrr::map(tibble::as_tibble, rownames = "sample") %>%
  purrr::map_dfr(tidyr::pivot_longer, -"sample", names_to = "seq", values_to = "reads") %>%
  dplyr::filter(reads > 0) %>%
  tidyr::extract(
    "sample",
    c("seq_run", "plate", "well", "region"),
    regex = "([pi][bs]_\\d{3})_(\\d{3})_([A-H]1?\\d)_(.+)"
  ) %>%
  # dplyr::mutate_at(
  #   "region",
  #   factor,
  #   levels = c("ITS1", "5_8S", "ITS2", "LSU1", "D1", "LSU2", "D2", "LSU3",
  #              "D3", "LSU4", "ITS", "LSU", "32S", "long")) %>%
  dplyr::group_by(seq_run, region, seq) %>%
  dplyr::summarize(reads = sum(reads)) %>%
  dplyr::mutate(length = nchar(seq)) %>%
  dplyr::ungroup()

region_table <- reads_table %>%
  dplyr::group_by(seq_run, region) %>%
  dplyr::summarize(
    ASVs = dplyr::n_distinct(seq),
    length_min = min(length),
    length_q1 = reldist::wtd.quantile(length, 0.25, weight = reads),
    length_med = reldist::wtd.quantile(length, 0.5, weight = reads),
    length_mean = weighted.mean(length, w = reads),
    length_q3 = reldist::wtd.quantile(length, 0.75, weight = reads),
    length_max = max(length),
    reads = sum(reads)
  )
loadd(big_seq_table_ITS2, cache = cache)
asv_table <- big_seq_table_ITS2 %>%
  tibble::as_tibble(rownames = "filename") %>%
  tidyr::gather(key = "seq", value = "reads", -1) %>%
  dplyr::filter(reads >= 1) %>%
  tidyr::extract(col = "filename",
                 into = c("seq.run", "plate", "well", "dir", "region"),
                 regex = "([a-z]+_\\d+)_(\\d+)_([A-H]1?[0-9])([fr]?)_([:alnum:]+).+") %>%
  dplyr::group_by(seq.run, seq) %>%
  dplyr::summarize(reads = sum(reads)) %>%
  tidyr::spread(key = seq.run, value = reads, fill = 0)

otu <- read_tsv(
  here("data/clusters/ITS2.table"),
  col_types = cols(
    .default = col_integer(),
    `#OTU ID` = col_character()
  )
) %>%
  column_to_rownames("#OTU ID") %>%
  as.matrix() %>%
  t() %>%
  as_tibble(rownames = "sample") %>%
  tidyr::extract(
    col = "sample",
    into = c("seq_run", "plate", "well"),
    regex = "([a-z]{2}_\\d{3})_(\\d{3})([A-H]1?\\d)"
  ) %>%
  tidyr::gather(key = "seq", value = "reads", -(1:3)) %>%
  dplyr::filter(reads >= 1) %>%
  dplyr::group_by(seq_run, seq) %>%
  dplyr::summarize(reads = sum(reads)) %>%
  tidyr::spread(key = seq_run, value = reads, fill = 0)
```

# Introduction

## Introduction to ECM communities

- Ectomycorrhizas (ECM) are a symbiosis between fungi and plant roots.
- x% of plants, y% of fungi
- The plants are often ecologically and economically important trees (Pinaceae, Fagaceae, Dipterocarpaceae, Amherstiae)
- The fungi provide nutrients and protection from pathogens, the plant provides sugar.
- Many well-known mushrooms are produced by ECM (Amanita, Cantharellus, Boletus) but many ECM produce inconspicuous (Tomentella) or no (Cenococcum) fruit bodies.
- Anyway the fruitbodies are ephemeral, so study of ECM communities requires looking at vegetative structures.
- Not easy to culture, so we need molecular methods.

## Long reads vs short reads/phylogenetic methods

- Clustering vs. phylogenetic methods
    - Clustering-based OTU approach may both "clump" and "split" species.
    - Distance-based clustering conflates intra-species variation and sequencing error
    - Denoising (DADA2 [@callahan2017], Deblur [@amir2017], UNOISE2 [@edgar2016]) attempts to control for sequencing error while leaving intra-species variation.
    - Phylogenetic community distance measures like UNIFRAC [@wong2016, look for earlier reference] are relatively insensitive to species/OTU delimitation, but require a phylogenetic tree.

- Short reads
    - 454 [@buee2009], Ion Torrent, Illumina [@schmidt2013].
    - For fungi, frequently ITS1 or ITS2 [@schoch2012]
    - Dependent on matching to database for taxonomic placement.
    - Phylogenetic placement algorithms [@matsen2010; @berger2011] are not easy to apply because ITS is not in most LSU alignments (different situation than V4/V5 of 18S)
    - Possible to place on taxonomy-based tree [@tedersoo2018]

- Long reads
    - Can include both LSU/SSU and ITS in same amplicon for better taxonomic placement [@Tedersoo2018]
    - can build tree directly
    - short reads from same location can potentially be mapped to tree. (but we didn't find that this works)
    - Sequencing depth tradeoff [@Kennedy2018]

## Turnover scale in ECM forests

*why is turnover scale interesting*

- @lilleskov2004 - autocorrelation only <2.6 m at most sites.  Based on Sanger sequencing root tips in temperate forests.

- Meta analysis @Bahram2013
  - Includes data from Benin (same site? ask Nourou/Leho) but this is unpublished
  - conclude that there is greater range of distance decay in tropical forests; because of less host availability? older forests?  *Russulaceae*?
  - 65 m in Benin

- @pickles2012a
  - T-RFLP of root tips, temperate forest
  - Autocorrelation < 3.4 m

- Data from African wooded savannas - @tedersoo2011 but only southern band
  - Irregular sampling with no samples nearer than 8m
  - based on sanger sequencing root tips
  - Significant Moran's I only in <10m class

*statement of question*

# Methods

## Sampling

Sampling was conducted at two sites (Ang: N 9.75456° W 2.14064
°; Gan: N 9.75678° W 2.31058 °) approximately 30 km apart in the _Forêt Reservée de l'Ouémé Supérieur_ (Upper Ouémé Forest Reserve) in central Benin.
Both locations were located in woodlands dominated by the ECM host tree _Isoberlinia doka_ (Caesalpinioideae).
At each site, 25 soil samples were along a linear transect at intervals of 1 m in May 2015.
One third of the sample locations (3-m spacing) were resampled one year later in June 2016.
For each sample, any coarse organic debris was removed from the soil surface and a sample of approximately 5cm×5cm×5cm was extracted with a knife blade.
Each sample was sealed in a plastic zipper bag and homogenized by shaking and manually breaking apart soil aggregations.
Approximately 50 mg total of soil was collected from two locations in the homogenized soil sample and placed into a separate 2.0 mL microtube containing 750 mL of lysis buffer and lysis beads (Xpedition^TM^ Soil/Fecal DNA miniprep, Zymo Research Corporation, Irvine, California, USA) and lysed in the field using a handheld bead-beater (TerraLyser^TM^; Zymo Research Corporation).
<!--The remainder of each sample was dried at 40°C with an electric dehydrator within 24-48 hours of collection for bulk chemical analysis. -->

An additional sample was collected at every sampling location in 2016 using an older batch of lysis buffer for preservation.
Sequencing results for these samples were found not to be comparable with results from the newer batch, so these samples were not included in spatial analyses.
However, reads from these sequences were included in the full bioinformatics workflow, including ASV calling, OTU clustering, and phylogenetic trees.

<!-- ## Soil Chemistry

  - Need to get methods from Nourou
  - or just not use it?
  -->

## DNA extraction, amplification, and sequencing

After field lysis, DNA was extracted using the Xpedition^TM^ Soil/Fecal Prep kit (see above).
DNA was quantified using fluorometrically using Quant-iT^TM^ PicoGreen^TM^ dsDNA (Thermo Fisher Scientific, Waltham, MA, USA) fluorescent indicator dye on a Infinite F200 plate spectrofluorometer (Tecan Trading AG, Männedorf, Switzerland) according to the manufacturer's protocol.

Two different fragments of the nuclear rDNA were amplified (Figure \@ref(fig:rDNA)).
The short amplicon (approximately 300 bp) included the full ITS2 region as well as parts of the flanking 5.8S and large subunit (LSU) rDNA, using gITS7 [@ihrmark2012] as the forward primer and a mix of ITS4 [@white1990amplification] and ITS4a [@urbina2016] as the reverse primer.
The long amplicon (approximately 1550 bp) included approximately 12 bp at the 3' end of the small subunit (SSU) rDNA, the full ITS region including the 5.8S rDNA, and approximately 950 bp at the 5' end of the LSU, including the first three variable regions (Figure \@ref(fig:rDNA)), using ITS1 [@white1990amplification] as the forward primer and LR5 [@vilgalys1990] as the reverse primer.

The gITS7 primers for the short amplicon were indexed for multiplexing (**supp info**).
Amplification was performed by polymerase chain reaction (PCR) in 20µl reactions containing 200 µM dNTP mix, 250 µM indexed gITS7 primer, 150 µM ITS4m, 2 mM McCl2, 0.1 U *Taq* polymerase (Dream *Taq*, Thermo Fisher Scientific, Waltham, MA, USA) and 3--7 ng purified DNA in Dream *Taq* buffer.
The reaction conditions were 10 min at 95°, followed by 35 cycles of 60 s at 95°, 45 s at 56°, and 50 s at 72°, and finally 3 min at 72°.
Each reaction was conducted in three technical replicates to reduce the effect of PCR stochasticity, which were pooled after amplification.

(ref:rDNA) Portion of the rDNA showing the 5.8S rDNA, partial SSU and LSU rDNA (thick lines), and internally transcribed spacer (ITS) regions (thin black lines).  D1-3 (grey) represent the first three variable regions in LSU [@michot1984], while LSU1-4 (black) represent the conserved regions. Primer sites used in this study are indicated in red (forward primers) and blue (reverse primers), and the resulting amplicons are shown with green braces.

```{tikz rDNA, fig.cap = "(ref:rDNA)", code = readLines("rDNA_amplicons.pgf"), fig.ext = "pdf"}

```

Both primers for the long amplicon were indexed for multiplexing (**supp info**).
PCR was performed as for the short amplicons, but with 500 µM of each of the two primers.
Reaction conditions were 10 min at 95°, 30 cycles of 45 s at 95°, 45 s at 59°, and 90 s at 72°, and finally 10 min at 72°.
Each reaction was performed in three technical replicates as for short amplicons.

Each PCR run also included a blank sample and a positive control consisting of freshly extracted DNA from a commercially purchased fruitbody of *Agaricus bisporus*.

Amplicons were purified using SPRI beads [@vesterinen2016] and quantified fluorometrically as above.
An aliquot of 100 ng of DNA from each sample (or the total PCR product if less than 100 ng) was pooled into two libraries each for long and short amplicons.
Each library was sequenced using Single Molecule Real Time (SMRT) sequencing on a Pacific Biosciences RS II sequencer at the Uppsala Genome Center (UGC; Uppsala Genome Center, Science
for Life Laboratory, Dept. of Immunology, Genetics and Pathology, Uppsala University, BMC, Box 815, SE-752 37 UPPSALA).
Short amplicon libraries were sequenced on two SMRT cells each, while long amplicon libraries were sequenced on four SMRT cells each.

Additionally the short amplicon libraries were combined and sequenced using an Ion S5  (Ion Torrent) sequencer using one 520 chip at UGC.
  
## Bioinformatics

Circular consensus sequence (CCS) basecalls for SMRT sequences were made using `ccs` version 3.4 [@pacificbiosciences2019] using the default settings.
The resulting sequences were demultiplexed and sequencing primers were removed using `cutadapt` version 1.18 [@martin2011].
Sequencing primers were similarly removed from the Ion Torrent sequences, but interference between the tagged gITS7 primers and the Ion XPress tags used in library prep made full demultiplexing of the Ion Torrent sequences impossible.

### Denoising

```{r length-qual}

parse_qstat <- function(d) {
  mutate_at(d, "file", basename) %>%
  tidyr::extract(col = "file", into = c("seq_run", "plate", "well"),
                 regex = "([pi][bs]_\\d{3})_(\\d{3})-?([A-H]1?\\d)?[rf]?[.].*")
}

demuxlength <- readd(qstats_length, cache = cache) %>%
  parse_qstat() %>%
  filter(is.na(step), !is.na(well)) %>%
  group_by(seq_run) %>%
  summarize(length = reldist::wtd.quantile(length, weight = nreads)) %>%
  deframe()

demuxqual <- readd(qstats_erate, cache = cache) %>%
  parse_qstat() %>%
  filter(is.na(step), !is.na(well)) %>%
  group_by(seq_run) %>%
  summarize(qual = round(weighted.mean(erate, w = nreads, na.rm = TRUE), 4)) %>%
  deframe()

readcounts <- 
  readd(qstats_n, cache = cache) %>%
  parse_qstat()

rawcounts <- readcounts %>%
  filter(is.na(step), is.na(well)) %>%
  group_by(seq_run) %>%
  summarize(nreads =  prettyNum(sum(nreads), big.mark = " ")) %>%
  deframe()

demuxcounts <- readcounts %>%
  filter(is.na(step), !is.na(well)) %>%
  group_by(seq_run) %>%
  summarize(nreads = prettyNum(sum(nreads), big.mark = " ")) %>%
  deframe()

regioncounts <- readcounts %>%
  filter(step == "lsux") %>%
  group_by(seq_run) %>%
  summarize(nreads = prettyNum(
    sum(nreads) %/% if (seq_run[1] == "pb_500") 14 else 4,
    big.mark = " ")
  ) %>%
  deframe()
```


We attempted to denoise both long and short amplicons using `DADA2` version `r packageVersion("dada2")` [@callahan2016; @callahan2019] according to the steps outlined in  the supplementary information in @callahan2019.
However, only `r region_table$ASVs[region_table$region=="long"]` amplicon sequence variants (ASVs) were obtained for the long amplicons, representing `r round(100*region_table$reads[region_table$region == "long"]/as.integer(gsub(" ", "", demuxcounts["pb_500"])), 1)`% of the trimmed reads.
We believe that this poor performance was due to a combination of long read length and low sequencing depth relative to community diversity.
The `DADA2` algorithm requires that the seed sequence of each ASV be represented by at least two error-free reads [@callahan2016].
If sequencing errors are uniformly distributed, then the probability that a given read will be error-free is $(1-\epsilon)^L$, where $\epsilon$ is the sequencing error rate and $L$ is the read length in base pairs.
Then the number of reads of a given sequence that would be required to obtain two error-free reads in expectation is $2/(1-\epsilon)^L$.
For the combination of long reads (median $L=`r demuxlength['pb_500']` \text{ bp}$ after trimming) and moderate error rate (mean $\epsilon= `r format(demuxqual['pb_500'], digits = 4)`$ based on ccs quality scores) for the long amplicon in this study, the expected number of reads required to achieve two error-free reads is `r format(as.integer(round(2/(1 - demuxqual['pb_500'])^demuxlength['pb_500'])), big.mark = " ")`.
Given the high diversity relative to sequencing depth in this study (`r region_table$ASVs[region_table$seq_run == "pb_483" & region_table$region == "short"]` ASVs based on PacBio short amplicons, `r demuxcounts["pb_500"]` trimmed long amplicon reads), this requirement could not have been met for the long amplicons except by the most abundant sequences.
In comparison, the equivalent requirement for the short amplicon ($L=`r demuxlength['pb_483']` \text{ bp}$, $\epsilon=`r demuxqual['pb_483']`$) is only `r round(2/(1 - demuxqual['pb_483'])^demuxlength['pb_483'], 1)` reads.
We therefore developed a new workflow to assemble ASVs from the long amplicons, as follows:

Raw reads were divided into shorter regions by matching to covariance models (CM), which are similar to stochastic hidden markov models (HMM), but account for both nucleotide sequence and RNA secondary structure [@eddy1994].
First, the 5.8S rDNA was located in each read by searching for Rfam model RF0002 [@kalvari2018] using `cmsearch` from Infernal 1.1.2 [@nawrocki2013], and all bases before the 5.8S were assigned to ITS1.
No attempt was made to remove the approximately 12 bp fragment of the SSU from the 5' end of ITS1 in the long amplicons; it was too short to be reliably detected by a CM or the HMMs employed by ITSx [@bengtsson-palme2013].
<!--This approach was able to identify both the 5' and 3' ends of the 5.8S rRNA more consistently and quickly than ITSx [@bengtsson-palme2013, data not shown].-->
A reference alignment including conserved RNA base pairing between and within the 5.8S and relevant portions of LSU was generated from the fungal 28S RNA seed alignment from the Ribosomal Data Project (RDP) release 11.5 [@glockner2017; @cole2014] by truncating after the LR5 primer site and using the reference line to annotate the variable regions *sensu* @michot1984 and @raue1988.
A CM was generated from the alignment using `cmbuild` from Infernal.
The fragment of each read beginning with the 5.8S rRNA was then aligned to the CM using `cmalign` from Infernal.
The annotation line in the CM alignment for each read was then used to split the reads into alternating more-conserved and less-conserved regions as shown in Figure \@ref(fig:rDNA),
where LSU1-4 represent the conserved regions of LSU flanking the variable D1-3 regions [@michot1984].
For short amplicons, only (partial) 5.8S, ITS2, and (partial) LSU1 were extracted.
Code to extract the regions, including annotated seed alignments and CMs, is available in the new R package `LSUx`, available on github (https://github.com/brendanf/LSUx).

Each of the extracted regions was independently filtered for length (Table \@ref(tab:region-length)) and a maximum of three expected errors.
Sequences were then dereplicated and denoised into amplicon sequencing variants (ASVs) using `DADA2` version `r packageVersion("dada2")` [@callahan2016; @callahan2019].
The error model for `DADA2` denoising was fit using the 5.8S region for long amplicons, and using the entire read for short amplicons.
Independent error models were fit for each sequencing run (i.e., long *vs.* short amplicons, different sequencing technologies).
For PacBio libraries, `DADA2` was run with complete pooling and a band size of 16.
For Ion Torrent libraries, pseudo-pooling and a band size of 32 were used, and the homopolymer gap penalty was set to -1, as recommended by the `DADA2` FAQ (https://benjjneb.github.io/dada2/faq.html).
Chimeras within each region were removed using `removeBimeraDenovoTable` from `DADA2`.

For each ITS2 ASV from the long amplicon data set, the denoised sequences for the other regions corresponding to the same sequencing reads were concatenated to form a set of full-length reads.
For reads which were not assigned a denoised sequence for each region, the raw read for the region was used instead.
Because ITS2 is the most variable of the amplified regions (Supplementary Figure \@ref(fig:regions)), reads with identical ITS2 regions are expected have highly similar sequences in the other regions, unless the amplicon was chimeric.
The concatenated ASVs representing each long read were aligned in R using the `DECIPHER` package [@wright2015].
Outlier sequences, as determined by mean pairwise distance from the rest of the alignment, were removed from each alignment using the `odseq` package [@jehl2015], using the default threshold of 0.025.
The consensus of the remaining aligned sequences was assigned as the full-length ASV sequence.
Full-length ASV sequences with more than three ambiguous bases (i.e., no nucleotide >50% at a given position) were removed *(how many)*.
The count and sample distribution of reads assigned to each ASV were calculated in order to form a sample x ASV community matrix.
A similar process was used to generate a consensus ITS (ITS1--5.8S--ITS2) and LSU (LSU1--D1--LSU2--D2--LSU3--D3--LSU4) sequence for each ASV.
The process of assigning consensus full-length ASVs was carried out using the new `tzara` package for R, available on github (https://github.com/brendanf/tzara).

### Taxonomy assignment

Taxonomic annotations of the Ribosomal Data Project's LSU fungal training set (RDP) version 11.5 [@cole2014] and Warcup ITS training set [@wang2007] were mapped to the taxonomic classification system used in the Unite database version 8 [@nilsson2019a].
In particular, the classification for fungi was according to @tedersoo2018, and for non-fungal eukaryotes was according to the proposed system of @tedersoo2017c.
Although the latter system is not formally published, it is consistent with the annotations for non-fungal eukaryotes in the Unite database.
Additionally, it is a system with both purportedly monophyletic taxa and a uniform set of taxon ranks, which make it more appropriate for sequence-based taxonomic assignment algorithms than more accepted classification systems such as that of the International Society of Protistologists [ @adl2019], which utilizes hierarchical nameless ranks.
FASTA format files of the re-annotated RDP and Warcup training sets are available at (*somewhere*).

Taxonomic assignment was performed to genus level separately on the ITS and LSU regions using Unite/Warcup and RDP, respectively, as taxonomic references.
For each region/reference combination, taxonomy was assigned using three algorithms:
the RDP Naïve Bayesian Classifier (NBC) as implemented in DADA2;
SINTAX [@edgar2016a] as implemented in VSEARCH v2.9.1 [@rognes2016];
and IDTAXA [@murali2018].
Each ASV was thus given up to nine preliminary taxonomic assignments (three region/reference combinations $\times$ three algorithms).

Sequences were assigned as ECM based on taxonomic assignments using the FUNGuild database [@nguyen2016funguild] via the R package `FUNGuildR` (https://github.com/brendanf/FUNGuildR).
All taxa which included "Ectomycorrhiza" in the guild assignment at any level of confidence were included.

### Clustering

For comparison with clustering-based methods, ASVs were clustered into operational taxonomic units (OTUs) at 97% similarity using VSEARCH v2.9.1 [@rognes2016].

### Alignment and phylogenetic inference

Unique LSU regions from long amplicon ASVs were aligned as RNA using DECIPHER [@wright2015] with up to 10 iterations of progressive alignment and conserved secondary structure calculation and 10 refinement iterations.
This alignment was truncated at a position after the D3 region corresponding to base 907 of the *Saccharomyces cerevisiae* S288C reference sequence for LSU, because several sequences had type 1 introns after this position [@holst-jensen1999].
Full length long amplicon ASVs (including ITS1, 5.8S, and ITS2 regions) were aligned and truncated in the same way.

<!--An attempt was made to refine the long amplicon alignment using Pasta [@mirarab2014a], but the resulting maximum likelihood (ML) trees did not improve on the ML achieved using the original alignment from DECIPHER.
Since ML is the optimization criterion used by Pasta, the original DECIPHER alignment was retained.-->

ML trees were produced using RAxML version 8.2.12 [@stamatakis2014] using the GTR+GAMMA model and rapid bootstrapping with the MRE_IGN stopping criterion.
The LSU tree was not constrained topologically, but the long amplicon tree was constrained by the result for the LSU tree.

*Short amplicon ASVs without a perfect match to one of the long amplicon ASVs were added to the long amplicon alignment using the `--add` option of MAFFT version 7.453 [@katoh2012] with a 10-mer based guide tree and two iterations.
The short ASVs were then placed on the long amplicon tree using EPA-NG version 0.3.6 [@barbera2019].
A "grafted" tree including the short amplicon ASVs in the most probable positions from the EPA-NG results was produced using GAPPA version 0.5.1 [@czech2019a].
When more than one short amplicon ASV was placed in the same position on the tree, GAPPA by default groups all of these sequences together in a polytomy.
The branch leading to each of these polytomies was deleted by setting its length to zero and then using the `d2multi` function from the `ape` package in R.
The resulting tree was used as a guide tree to construct a final ML tree in RAxML, using the GTR+GAMMA model, in order to resolve relationships between different sequences assigned to the same branch.
No bootstrapping was performed on the final tree.* -- this didn't work.

The tree was rooted outside the Fungi by using the most abundant ASV which was confidently assigned to a non-fungal kingdom by all 6 applicable taxonomic assignment methods.
Assignments based on Warcup were not used at this step because non-Fungi are not included in the dataset.
Inspection of the tree along with taxonomic assignments revealed that two ASVs assigned to the genus *Tulasnella* (Basidiomycota), which is known to have accelerated evolution in the rDNA [@moncalvo2006], were nested within the Metazoa, so they were excluded.
The kingdom Fungi was then identified as the minimal clade containing all remaining ASVs which were confidently identified (consensus of at least 6 of 9 assignments) to a fungal phylum.
ASVs falling outside this clade were not included in the fungal community analysis.

Taxonomic assignments of ASVs which were represented in the long amplicon dataset were refined using the phylogenetic tree (Supplementary Figure \@ref(fig:phylotax)).
A taxon at a particular rank was assigned to a node and all its descendents if that taxon was consistent with the reference-based taxonomic assignments for each of the descendents.
A taxon assignment was considered to be consistent if at least one algorithm assigned that taxon at greater than 50% confidence, or if no algorithm successfully classified the sequence at greater than 50% confidence.
The result of this process was to give a taxonomic assignment to ASVs which were previously unassigned if they were nested within a clade where which was consistently given an assignment, as well as clarify the assignment of ASVs where different algorithms had resulted in different assignments, but only one of these was consistent with the assignments of other ASVs in the same clade.

<!--
          - preliminary alignment of 32S to RDP covariance model with `cmalign` from Infernal (aligns only conserved regions)
          - concatenate ITS1 to beginning of alignment
          - create guide tree using alignment of only conserved, gap-free columns in preliminary alignment, using UPGMA in DECIPHER [@wright2016]
          - realign nonconserved sites using MLocARNA (progressive simultaneous alignment and folding) from LocARNA 2.0.0RC8 [@will2007; @will2012; @will2013]. -->
          
## Statistics

Ecological community dissimilarity matrices were calculated using the ASV/OTU based Bray-Curtis metric (both long and short amplicons) and the phylogenetically based weighted UNIFRAC method (only long amplicons) in `phyloseq` version `r packageVersion("phyloseq")`.
Each of these distance matrices was used to calculate a Mantel correlogram for distances of 0--12 m.
Separate correlograms were drawn for samples taken during the same year, and samples separated in time by one year, in order to assess the degree to which the soil community changes over the course of one year.

Additionally, empirical variograms were generated by plotting mean community dissimilarity as a function of spatial distance and temporal separation, and fit using a joint exponential spatio-temporal model using the `fit.StVariogram` function from `gstat` version `r packageVersion("gstat")` [@R-gstat].
The mean dissimilarity between samples taken in different transects (distance $\approx$ 30 km) was also included as a single point for each year for the purposes of fitting the variogram function.

# Results

## Sequencing

Long (short) amplicon sequencing with PacBio yielded `r rawcounts["pb_500"]` (`r rawcounts["pb_483"]`) circular consensus reads, of which `r demuxcounts["pb_500"]` (`r demuxcounts["pb_483"]`) were successfully demultiplexed.
The 5.8S region was detected in `r regioncounts["pb_500"]` (`r regioncounts["pb_483"]`) reads.
Ion Torrent sequencing yielded `r demuxcounts["is_057"]` demultiplexed reads, with the 5.8S region detected in `r regioncounts["is_057"]`.

(ref:readcounts) Number of Amplicon Sequence Variants (ASV) and reads at different pipeline stages.
*Raw*: raw reads as delivered by sequencing center;
*Trim*: reads with primers and demultiplexing indices removed;
*LSUx*: reads with a positive CM hit for 5.8S, allowing regions to be extracted;
*ITS2*: ASVs obtained for the ITS2 region, and reads successfully mapped to an ITS2 ASV;
*short*, *ITS*, *LSU*, *long*: ITS2-based ASVs mapped to consensus ASVs for longer regions, where \"short\" and \"long\" denote the full-length short and long amplicons, respectively.
Short amplicons were mapped to full ITS, LSU, and long amplicon ASVs when 

```{r}
bioinf_table <- bind_rows(
  enframe(rawcounts, name = "seq_run", value = "reads") %>%
    mutate(
      reads = as.integer(gsub(" ", "", reads)),
      step = "Raw"
    ),
  enframe(demuxcounts, name = "seq_run", value = "reads") %>%
    mutate(
      reads = as.integer(gsub(" ", "", reads)),
      step = "Trim"
    ),
  enframe(regioncounts, name = "seq_run", value = "reads") %>%
    mutate(
      reads = as.integer(gsub(" ", "", reads)),
      step = "LSUx"
    ),
  filter(region_table, region == "ITS2") %>%
    select(seq_run, reads, step = region, ASVs),
  pivot_longer(asv_table, -1, names_to = "seq_run", values_to = "reads") %>%
    filter(reads > 0) %>%
    mutate_at("seq", chartr, old = "T", new = "U") %>%
    inner_join(
      select(readd(allseqs, cache = cache), seq = ITS2, long, short, ITS, LSU) %>%
        pivot_longer(-1, names_to = "region", values_to = "consensus") %>%
        filter(!is.na(consensus)) %>%
        select(-consensus) %>%
        unique(),
      by = "seq"
    ) %>%
    group_by(seq_run, region) %>%
    summarize(reads = sum(reads, na.rm = TRUE), ASVs = n()) %>%
    select(seq_run, reads, step = region, ASVs)
) %>%
  left_join(select(datasets, seq_run, tech, amplicon), by = "seq_run") %>%
  mutate(
    step = ifelse(tech == "Ion" & step == "Trim", "Raw", step),
  ) %>%
  select(tech, amplicon, step, reads, ASVs) %>%
  pivot_longer(c("reads", "ASVs"), names_to = "type", values_to = "count") %>%
  filter(!is.na(count)) %>%
  mutate(
    step = factor(step, levels = c("Raw", "Trim", "LSUx", "ITS2",
                                   "short", "ITS", "LSU", "long")),
    tech = factor(tech, levels = c("PacBio", "Ion", "Illumina")),
    amplicon = factor(amplicon, levels = c("Long", "Short")),
    type = factor(type, c("ASVs", "reads"))
  ) %>%
  arrange(tech, amplicon, type) %>%
  pivot_wider(
    id_cols = "step",
    names_from = c("tech", "amplicon", "type"),
    values_from = c("count")
    ) %>%
  arrange(step) %>%
  column_to_rownames("step")

options(knitr.kable.NA = '–')
bioinf_header <- tibble(name = names(bioinf_table)) %>%
  separate(name, into = c("tech", "amplicon", "type")) 
bioinf_table %>%
  set_names(gsub(".*_", "", names(.))) %>%
  kable(
    booktabs = TRUE,
    caption = "(ref:readcounts)",
    align = "rrrrrr",
    format.args = list(big.mark = "\\,"),
    linesep = c(rep("", 3), rep("\\addlinespace", 2), rep("", 4)),
    escape = FALSE
    ) %>%
  kableExtra::add_header_above(
    header = c(
      " " = 1,
      bioinf_header$amplicon[c(TRUE, FALSE)] %>% set_names(rep(2, length(.)), .)
    )
  ) %>%
  kableExtra::add_header_above(
    header = c(
      " " = 1,
      rle(bioinf_header$tech) %$% set_names(lengths, values)
    )
  )
```





- How many reads passed quality control
- how many became ASVs
- how many ASVs in different regions

```{r agaricus-check}
agaricus <- readd(taxon_table, cache = cache) %>%
  filter(rank == "genus", taxon == "Agaricus", n_diff == 1) %$%
  unique(label)
agaricus_reads <- readd(proto_physeq, cache = cache) %>%
  phyloseq::subset_samples(sample_type == "Pos") %>%
  prune_taxa(taxa = agaricus) %>%
  prune_taxa(taxa = colSums(otu_table(.)) > 0) %>%
  merge_samples("seq_run") %>%
  otu_table()

agaricus_order <- readd(proto_physeq, cache = cache) %>%
  merge_samples("seq_run") %>%
  otu_table() %>%
  apply(MARGIN = 1, order, decreasing = TRUE) %>%
  apply(MARGIN = 2, match, x = 1)
```

## Results from control

- *Agaricus bisporus* from positive control was most abundant ASV in Ion and long PacBio runs, 5th highest in short PacBio
  - only one ASV in both PacBio runs
  - four ASVs in IonTorrent -- probably due to sequencing errors not controlled by DADA2 (most abundant ASV had `r agaricus_reads["is_057", "39d80c19"][[1]]` reads, others had `r glue::glue_collapse(c(unclass(agaricus_reads["is_057", -1])), sep = ", ", last = ", and ")`)

(ref:readcap) Comparison between read numbers for different sequencing strategies, by ASV (left) and 97% OTU (right). ASVs/OTUs which were detected by one sequencing strategy but not the other are plotted as tick marks along the axes. Dashed line represents a constant ratio of read numbers. The blue line is a LOESS smooth of the data, with associated uncertainty in grey shading. $R^2$ value displayed is for log-transformed non-zero read numbers.

## Comparison of read counts from different technologies

```{r pb-vs-it, fig.cap="(ref:readcap)", fig.height=8}
big_table <- bind_rows(
  mutate(asv_table, type = "ASV"),
  mutate(otu, type = "OTU")
) %>%
  select(-seq)

multi_table <- crossing(
  x_var = factor(datasets$seq_run, ordered = TRUE),
  y_var = factor(datasets$seq_run, ordered = TRUE),
  type = c("ASV", "OTU")
) %>%
  filter(
    x_var < y_var,
    x_var %in% names(big_table),
    y_var %in% names(big_table)
  ) %>%
  mutate_all(as.character) %>%
  group_by(x_var, y_var, type) %>%
  group_modify(
    function(d, g) {
      big_table %>%
        filter(type == g$type) %>%
        select(x = !!g$x_var, y = !!g$y_var) %>%
        filter(x > 0 | y > 0)
    }
  )


comparisons <- multi_table %>%
  group_modify(
    function(d, g) {
      filter_all(d, ~. > 0) %>%
        mutate_all(log10) %>%
      {bind_cols(
      lm(y ~ x, .) %>%
        broom::glance(.),
      lm(y ~ offset(x), .) %>%
        broom::tidy(.) %>%
        select(term, estimate) %>%
        pivot_wider(names_from = term, values_from = estimate)
      )}
    }
  ) %>%
  mutate(
    label = paste("R^2 ==", formatC(r.squared, format = "f", digits = 2))
  )

# comparisons <- crossing(
#   x_var = factor(datasets$seq_run, ordered = TRUE),
#   y_var = factor(datasets$seq_run, ordered = TRUE),
#   type = c("ASV", "OTU")
# ) %>%
#   filter(y_var < x_var) %>%
#   mutate_all(as.character) %>%
#   group_by(x_var, y_var, type) %>%
#   group_modify(function(d, g) {
#     big_table %>%
#       filter(type == g$type) %>%
#       select(x = !!g$x_var, y = !!g$y_var) %>%
#       filter(.data[[g$x_var]] > 0 & .data[[g$y_var]] > 0) %>%
#       mutate_all(log10) %>%
#       lm() %>%
#       {bind_rows(
#       broom::glance(.),
#       broom::tidy(.) %>%
#         select(term, estimate) %>%
#         pivot_wider(names_from = term, values_from = estimate)
#       )} %>%
#       bind_cols(d, .)
#     }) %>%
#   mutate(
#     label = paste("R^2 ==", formatC(r.squared, format = "f", digits = 2))
#   )

compR2 <- function(x, y, type) {
  format(filter(comparisons, x == !!x, y == !!y, type == !!type)$r.squared, digits = 2, drop0trailing = FALSE)
}

# p <- multi_table %>%
#   filter(x > 0, y > 0, type == "ASV") %>%
#   ggplot(aes(y = y, x = x)) +
#   geom_point(alpha = 0.2, shape = 1) +
#   scale_x_log10() +
#   scale_y_log10(limits = c(1, 1e4)) +
#   coord_equal() +
#   xlab(NULL) +
#   ylab(NULL) +
#   geom_rug(aes(y = y), sides = "l", alpha = 0.2,
#            data = multi_table %>% filter(x == 0, y > 0)) +
#   geom_rug(aes(x = x), sides = "b", alpha = 0.2,
#            data = multi_table %>% filter(y == 0, x > 0)) +
#   facet_grid(y_var ~ x_var, switch = "both", space = "free") +
#   stat_smooth(method = "loess", formula = y ~ x) +
#   geom_abline(aes(intercept = `(Intercept)`, slope = 1),
#               linetype = 2L, alpha = 0.5, data = comparisons) +
#   geom_text(
#     aes(label = label),
#     data = comparisons,
#     x = 1,
#     y = 3.5,
#     color = "black",
#     hjust = 0,
#     parse = TRUE,
#     inherit.aes = FALSE
#   ) +
#     theme(strip.placement = "outside", strip.background = element_blank())
# g <- ggplotGrob(p)
# g$grobs[g$layout$name %in% c("panel-1-2")] <- NULL
# g$layout <- g$layout[!(g$layout$name %in% c("panel-1-2")),]
# grid.newpage()
# grid.draw(g)

expand_seq_run <- function(labels) {
  lapply(
    labels,
    )
}

read_comparison <- function(multi_table, comparisons, type) {
  multi_table <- filter(multi_table, type == !!type)
  comparisons <- filter(comparisons, type == !!type)
  p <- multi_table %>%
    filter(x > 0, y > 0) %>%
    ggplot(aes(y = y, x = x)) +
    geom_point(alpha = 0.2, shape = 1) +
    scale_x_log10() +
    scale_y_log10(limits = c(1, 1e4)) +
    coord_equal() +
    xlab(NULL) +
    ylab(NULL) +
    geom_rug(aes(y = y), sides = "l", alpha = 0.2,
             data = multi_table %>% filter(x == 0, y > 0)) +
    geom_rug(aes(x = x), sides = "b", alpha = 0.2,
             data = multi_table %>% filter(y == 0, x > 0)) +
    facet_grid(y_var ~ x_var, switch = "both", space = "free", ) +
    stat_smooth(method = "loess", formula = y ~ x) +
    geom_abline(aes(intercept = `(Intercept)`, slope = 1),
                linetype = 2L, alpha = 0.5, data = comparisons) +
    geom_text(
      aes(label = label),
      data = comparisons,
      x = 0.5,
      y = 3.5,
      color = "black",
      hjust = 0,
      parse = TRUE,
      inherit.aes = FALSE
    ) +
    theme(strip.placement = "outside", strip.background = element_blank())
  g <- ggplotGrob(p)
  g$grobs[g$layout$name %in% c("panel-1-2")] <- NULL
  g$layout <- g$layout[!(g$layout$name %in% c("panel-1-2")),]
  g
}
ggpubr::ggarrange(
  read_comparison(multi_table, comparisons, type = "ASV"),
  read_comparison(multi_table, comparisons, type = "OTU"),
  ncol = 1,
  labels = "auto",
  label.x = 0.9
)

read_comparison <- function(big_table, comparisons, x, y, xlab, ylab) {
  x_var <- enquo(x)
  y_var <- enquo(y)
  big_table %>%
  filter(!!x_var > 0, !!y_var > 0) %>%
  ggplot(aes(x = !!x_var, y = !!y_var)) +
  geom_point(alpha = 0.2, shape = 1) +
  scale_x_log10() +
  scale_y_log10(limits = c(1, 1e4)) +
  coord_equal() +
  xlab(xlab) +
  ylab(ylab) +
  geom_rug(aes(y = !!y_var, x = 1), sides = "l", alpha = 0.2,
           data = big_table %>% filter(!!x_var == 0, !!y_var > 0)) +
  geom_rug(aes(y = !!x_var), sides = "b", alpha = 0.2,
           data = big_table %>% filter(!!y_var == 0, !!x_var > 0)) +
  stat_smooth(method = "loess", formula = y ~ x) +
  geom_abline(aes(intercept = mean(log10((!!y_var)[(!!y_var) >= 1])) -
                    mean(log10((!!x_var)[(!!x_var) >= 1])), slope = 1),
              linetype = 2L, alpha = 0.5) +
  geom_text(
    aes(label = label),
    data = filter(comparisons, .data$x == quo_name(x_var), .data$y == quo_name(y_var)),
    x = 1,
    y = 3.5,
    color = "black",
    hjust = 0,
    parse = TRUE,
    inherit.aes = FALSE
  ) +
  facet_wrap(~type, strip.position = "right", scales = "free")
}
# ggpubr::ggarrange(
#   ncol = 1,
#   labels = "auto",
#   read_comparison(
#     big_table,comparisons,
#     is_057, pb_500,
#     "Ion Torrent Short Reads", "PacBio Long Reads"),
#   read_comparison(
#     big_table, comparisons,
#     is_057, pb_483,
#     "Ion Torrent Short Reads", "PacBio Short Reads"),
#   read_comparison(
#     big_table, comparisons,
#     pb_483, pb_500,
#     "PacBio Short Reads", "PacBio Long Reads")
# )
```

Figure \@ref/fig:pb-vs-it) shows the correspondence between the read count for different ASVs/OTUs

- Figure \@ref(fig:pb-vs-it)a
  - ASVs/OTUs are correlated between Ion Torrent and PacBio; 
  ASVs $R^2 = `r compR2("is_057", "pb_500", "ASV")`$; 
  OTUs $R^2 = `r compR2("is_057", "pb_500", "OTU")`$
  - "hook" at lower left due to sampling effects with rare species
  - lots of ASVs/OTUs detected in only one tech

- Figure \@ref(fig:pb-vs-it)b
  - very few PacBio OTUs undetected by Ion torrent from same library; only rare OTUS undetected by PacBio
  - $R^2 = `r compR2("is_057", "pb_483", "OTU")`$
  - sequencing technologies yield comparable results (given read depth) with sufficient clustering
  - not such good match with ASVs -- suggests DADA2 doesn't perform equally on different datasets

- Figure \@ref(fig:pb-vs-it)c
  - No "hook", because depth is similar
  - still lots of ASVs/OTUs detected by only one amplicon -- primer bias.

## Distance decay

(ref:correlog-cap) Mantel correlograms showing the correlation between Bray-Curtis (top two rows) or weighted Unifrac (bottom row) dissimilarities and spatial distance, for short (top row) and long (bottom two rows) amplicons, and for the entire soil fungal community (left) or only ECM taxa (right).  Unifrac distance was not calculated for short amplicons because it requires that the sequences are placed on a phylogenetic tree.

```{r correlog, fig.cap="(ref:correlog-cap)"}

light_plan %>%
  filter(startsWith(target, "correlog")) %>%
  select(target) %>%
  separate(
    target,
    into = c("step", "guild", "metric", "tech", "amplicon", "tdist"),
    sep = "_",
    remove = FALSE
  ) %>%
  mutate(
    tdist = paste(tdist, "year"),
    guild = plyr::mapvalues(guild, c("fungi", "ecm"), c("all Fungi", "ECM")),
    metric = plyr::mapvalues(metric, c("bray", "wunifrac"), c("Bray-Curtis", "Weighted UNIFRAC")),
    amplicon = factor(amplicon, levels = c("short", "long"), labels = c("short amplicon", "long amplicon"))
  ) %>%
  mutate_at("target", purrr::map, readd, character_only = TRUE, cache = cache) %>%
  mutate_at("target", purrr::map, "mantel.res") %>%
  mutate_at("target", purrr::map, as.data.frame) %>%
  unnest(target) %>%
  filter(complete.cases(.)) %>%
  mutate(Significant = `Pr(corrected)` < 0.05) %>%
  ggplot(aes(class.index, Mantel.cor, group = tdist, color = tdist, shape = Significant)) +
  geom_point(size = 3) +
  geom_line(alpha = 0.3, size = 1.5) +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_line(aes(y = exp(predict(bc_fit)))) +
  scale_y_continuous(limits = c(-0.05, NA), name = "Mantel correlation") +
  scale_x_continuous(breaks = c(0, 3, 6, 9, 12)) +
  scale_color_discrete(name = "Time lag") +
  xlab("Distance (m)") +
  facet_grid(metric + amplicon ~ guild, scales = "fixed") +
  scale_shape_manual(values = c("TRUE" = 16, "FALSE" = 1))
```

Figure \@ref(fig:correlog): 

  - Long amplicons found longer autocorrelation of Bray-Curtis for all fungi, but not ECM.  Is this due to some particular group?
  - Long amplicon also detects some autocorrelation even after 1 year, absent in other tests.
  - Unifrac has less significant autocorrelation.


(ref:variog) Spatial variogram fits for community dissimilarities. Each point represents one pair of samples taken at the same time.  Thick blue and red lines represent the empirical variogram (mean of community dissimilarities at each distance).  Thin lines is an exponential fit for the relationship between community dissimilarity and spatial distance.  Horizontal dashed lines represent the values of the fit function at zero distance ("nugget") and infinite distance ("sill").  The vertical dashed line is at the characteristic distance of the fit function ("range").

```{r variog, fig.cap = "(ref:variog)", include = FALSE}
variog_data <- light_plan %>%
  filter(step == "variofit") %>%
  select(variofit, variog, guild, metric, tech, amplicon) %>%
  mutate_at(c("guild", "metric", "tech", "amplicon"), str_replace_all, "\"", "") %>%
  mutate(
    guild = plyr::mapvalues(guild, c("fungi", "ecm"), c("all Fungi", "ECM")),
    metric = plyr::mapvalues(metric, c("bray", "wunifrac"), c("Bray-Curtis", "Weighted UNIFRAC")),
    amplicon = factor(amplicon, levels = c("short", "long"), labels = c("short amplicon", "long amplicon"))
  ) %>%
  mutate_at(c("variofit", "variog"), lapply, readd, character_only = TRUE, cache = cache) %>%
  mutate(sills = purrr::map(variofit, ~ cumsum(.$psill)),
         range = purrr::map_dbl(variofit, ~.$range[2]),
         vgline = purrr::map(variofit, gstat::variogramLine, maxdist = 25, n = 100))

variog_points <- unnest(variog_data, c("variog")) %>%
  filter(dist <= 25)
variog_empir <- variog_points %>%
  group_by(guild, metric, tech, amplicon, dist) %>%
  summarize_at("gamma", mean)
variog_sills <- unnest(variog_data, "sills")
variog_fitline <- unnest(variog_data, "vgline")
  

variog_points %>%
  ggplot(aes(dist, gamma)) +
  geom_hline(data = variog_sills, aes(yintercept = sills), linetype = "dashed", color = "gray50") +
  geom_vline(data = variog_data, aes(xintercept = range), linetype = "dashed", color = "gray50") +
  geom_point(shape = 1, alpha = 0.2) +
  geom_line(data = variog_empir, color = "blue", size = 1.5) +
  geom_line(data = variog_fitline,
            aes(dist, gamma), inherit.aes = FALSE, color = "red", size = 0.5) +
  scale_x_continuous(expand = expand_scale(0, 0), limits = c(0, 25), name = "Distance (m)") +
  ylab("Community dissimilarity") +
  facet_grid(guild ~ metric + amplicon)
  

```

(ref:spatio) Spatiotemporal variogram fits for community dissimilarities. The thick lines represent the empirical variogram (mean of community distances at each spatial distance) for samples taken at the same time (red) or separated by one year (blue). Thin lines are an exponential fit to the variograms.

## Spatio-temporal variogram
```{r spatio-temporal, fig.cap = "(ref:spatio)"}
variog_data <- light_plan %>%
  filter(step == "variofitST") %>%
  select(variofitST, variogST, guild, metric, tech, amplicon) %>%
  mutate_at(c("guild", "metric", "tech", "amplicon"), str_replace_all, "\"", "") %>%
  mutate(
    guild = plyr::mapvalues(guild, c("fungi", "ecm"), c("all Fungi", "ECM")),
    metric = plyr::mapvalues(metric, c("bray", "wunifrac"), c("Bray-Curtis", "Weighted UNIFRAC")),
    amplicon = factor(
      amplicon,
      levels = c("short", "long"),
      labels = c("short amplicon", "long amplicon")
    )
  ) %>%
  mutate_at(
    c("variogST", "variofitST"),
    lapply,
    readd,
    character_only = TRUE,
    cache = cache)

variog_points <- unnest(variog_data, c("variogST")) %>%
  filter(dist <= 25) %>%
  mutate_at("timelag", factor)

variog_empir <- variog_points %>%
  # mutate(bin = cut(dist, c(1:13 - 0.5, 14.5, 16.5, 19.5, 24.5))) %>%
  group_by(guild, metric, tech, amplicon, dist, timelag) %>%
  summarize(
    gamma = mean(gamma),
    # dist = mean(dist),
    n = n()
  )

variog_confint <- variog_points %>%
  group_by(guild, metric, tech, amplicon, dist, timelag) %>%
  summarize(
    lower = quantile(gamma, 0.025),
    upper = quantile(gamma, 0.975)
  )

variog_fit <- variog_data %>%
  mutate_at("variofitST", lapply,
            gstat:::vgmMetric,
            expand_grid(spacelag = seq(1, 25, 0.5), timelag = 0:1)
            ) %>%
  unnest(variofitST) %>%
  rename(dist = spacelag) %>%
  mutate_at("timelag", factor)

variog_empir %>%
  ggplot(aes(dist, gamma, color = timelag, size = n)) +
  # geom_hline(data = variog_sills, aes(yintercept = sills), linetype = "dashed", color = "gray50") +
  # geom_vline(data = variog_data, aes(xintercept = range), linetype = "dashed", color = "gray50") +
  # geom_jitter(shape = 46, alpha = 0.5) +
  # geom_line(size = 1.5, alpha = 0.5) +
  geom_point(alpha = 0.5) +
  # geom_smooth(data = variog_points, aes(fill = timelag), color = FALSE, alpha = 0.5) +
  geom_line(data = filter(variog_fit, timelag == 1), size = 0.5, color = "darkcyan", alpha = 0.8) +
  geom_line(data = filter(variog_fit, timelag == 0), size = 0.5, color = "red1", alpha = 0.8) +
  scale_x_continuous(expand = expand_scale(0, 0), limits = c(0, 25), name = "Distance (m)") +
  scale_color_discrete() +
  scale_y_continuous(name = "Community dissimilarity") +
  facet_grid(metric + amplicon ~ guild, scales = "free")

```

(ref:variofit) Parameters for variogram fits shown in Figure \@ref(fig:spatio-temporal). Range: range at which exponential function is at 95% of its maximum value; Anisotropy: effective spatial distance represented by one year; the characteristic range of the exponential function in the time domain.

```{r variofit}
variog_data %>%
  mutate_at("variofitST", lapply, purrr::compose(as.data.frame, as.list, gstat::extractPar)) %>%
  unnest(variofitST) %>%
  arrange(metric, amplicon, guild) %>%
  select(Guild = guild, Amplicon = amplicon, Metric = metric,
         Range = range, Anisotropy = anis) %>%
  mutate(Range = 3*Range,
         "Time Range" = Range/Anisotropy,
         "Time Range" = ifelse(`Time Range` > 100, NA, `Time Range`)) %>%
  mutate_at(c("Range", "Time Range"), formatC, digits = 1,
            format = "f") %>%
  mutate_at("Range", paste, "m") %>%
  mutate_at("Anisotropy", paste, "m/a") %>%
  mutate_at("R/A", paste, "a") %>%
  mutate_at("R/A", str_replace, "NA a", "-") %>%
  mutate_at("Amplicon", fct_relabel, str_replace, " amplicon", "") %>%
  kable(booktabs = TRUE, caption = "(ref:variofit)")
```


Figure \@ref(fig:spatio-temporal) and Table \@ref(tab:variofit):

 - Fit looks good for long Pacbio w/Bray-Curtis.
 - Unifrac shows unconvincing distance structure. (No surprise that the model doesn't fit well)
 - Distance structure for short amplicon is really confusing.  Why are the samples 25 m apart so similar? (Even after 1 year?) Could the samples be mixed up? Or is this just a statistical artifact (very few sample pairs have that separation).
 - ECM has shorter range and less anisotropy for all metrics
   - shorter range = more spatially variable
   - less anisotropy = less temporally variable

# Discussion

# Acknowledgements

The authors would like to acknowledge support of the National Genomics Infrastructure (NGI) / Uppsala Genome Center and UPPMAX for providing assistance in massive parallel sequencing and computational infrastructure.
Work performed at NGI / Uppsala Genome Center has been funded by RFI / VR and and Science for Life Laboratory, Sweden

# Bibliography {-}

<div id="refs"></div>

\processdelayedfloats

# Supplementary Information {-}

\beginsupplement

(ref:phylotax) Hypothetical example of phylogenetic refinement of taxonomic assignments.
In the example, a clade includes  seven OTUs (A-F), which have been identified by two methods as belonging to taxa "Tax1" or "Tax2", or are unidentified ("unk"), as shown in the tip labels.
No taxon is assigned at node 1, because one of the child branches (A) is completely unassigned.
No taxon is assigned at node 2, because the assignments at C and F are inconsistent.
Node 3 is assigned to Tax1 because this is consistent with at least one of the assignments for both B and C.
Node 4 (and thus also node 5) is assigned to Tax2 because this is consistent with at least one of the assignments for D and F, and because E is completely unassigned.

```{r phylotax, fig.height = 2, fig.width = 3, fig.cap = "(ref:phylotax)"}
extree <-
  treeio::as.treedata(ape::read.tree(text = "(A:1,((B:1,C:1):1,((E:1,F:1):1,D:1):1):1);")) %>%
  tidytree::full_join(
    tibble(label = LETTERS[1:6],
           tax1 = c("unk", "Tax1", "Tax2", "Tax2", "unk", "unk"),
           tax2 = c("unk", "Tax2", "Tax2", "Tax1", "unk", "Tax1")),
    by = "label"
  )
ggtree::ggtree(extree) +
  ggtree::geom_tiplab(x = 4, align = 2) +
  xlim(0, 6) +
  ggtree::geom_tiplab(
    aes(color = tax1, label = tax1),
    x = 4.7,
    hjust = 0.5
  ) +
  ggtree::geom_tiplab(
    aes(color = tax2, label = tax2),
    x = 5.7,
    hjust = 0.5
  ) +
  ggtree::geom_tiplab(x = 5.2, label = "/", hjust = 0.5) +
  ggtree::geom_nodelab(aes(label = node - 6), geom = "label") +
  ggtree::geom_hilight(node = 10, fill = "steelblue", extendto = 4) +
  ggtree::geom_hilight(node = 9, fill = "tomato", extendto = 4) +
  scale_color_manual(values = c(Tax1 = "steelblue", Tax2 = "tomato", unk = "grey50")) +
  scale_y_reverse()
```

(ref:full-length) Comparison of the length of sequences from different length amplicons and sequencing technologies.  *a*) Length distribution.  *b*) Empirical cumulative distribution function.

```{r full-length, fig.cap = "(ref:full-length)", fig.height = 6}
full_dens <- reads_table %>%
  dplyr::left_join(dplyr::select(datasets, seq_run, tech)) %>%
  dplyr::filter(region %in% c("long", "short")) %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(
    amplicon = ifelse(seq_run == "pb_500", "Long", "Short") %>%
      factor(levels = c("Short", "Long")),
    reads = reads / sum(reads)
  ) %>%
  ggplot(aes(length, weight = reads, color = seq_run, group = seq_run)) +
  stat_density(bw = 0.5, geom = "line", position = "identity") +
  scale_color_brewer(type = "qual", guide = "none", palette = "Set2") +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = NULL) +
  facet_wrap(~tech + amplicon, ncol = 1, strip.position = "right", scales = "free_y")

full_ecdf <- reads_table %>%
  dplyr::filter(region  %in% c("long", "short")) %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(reads = reads / sum(reads)) %>%
  ggplot(aes(length, weight = reads, color = seq_run, group = seq_run)) +
  stat_ecdf(geom = "line") +
  scale_color_brewer(type = "qual", labels = c("Short amplicon - Ion", "Short amplicon - PacBio", "Long amplicon - PacBio"), name = NULL, palette = "Set2") +
  scale_y_continuous(name = "Cumulative read fraction") +
  scale_x_continuous(name = "Length (bp)") +
  theme(legend.position = c(0.98, 0.02), legend.justification = c(1, 0))

ggpubr::ggarrange(full_dens, full_ecdf, ncol = 1, labels = "auto")
```

```{r region-length}
regions %>%
  select(Region = region, "Min. length" = min_length, "Max. length" = max_length) %>%
  right_join(
    tibble(Region = c("ITS1", "5_8S", "ITS2", "LSU1", "D1", "LSU2", "D2", "LSU3", "D3", "LSU4")),
    by = "Region"
    ) %>%
  mutate_at("Region", str_replace_all, "_", ".") %>%
  knitr::kable(
    booktabs = TRUE,
    caption = "Minimum and maximum allowed lengths for each extracted region."
  )
```

(ref:region-asv) Plot of total number of ASVs recovered vs. fraction of reads successfully mapped to ASVs for different rDNA regions extracted from long PacBio amplicons using `LSUx`. Some reggions were formed by concatenation of extracted regions, as follows: LSU = LSU1--D1--LSU2--D2--LSU3--D3--LSU4; ITS = ITS1--5.8S--ITS2; 32S = 5.8S--ITS2--LSU; long = ITS--LSU. For this figure, subregions were concatenated prior to generating ASVs with `DADA2`.

```{r regions, fig.cap="(ref:region-asv)"}
region_table %>%
  dplyr::filter(seq_run == "pb_500") %>%
  ggplot(aes(reads, ASVs, color = length_med, label = region)) +
  geom_point() +
  ggrepel::geom_text_repel() +
  scale_color_gradientn(colors = c("blue", "red", "green1"), limits = c(30, 2000), breaks = c(50, 150, 400, 1000), trans = "log10", name = "median length") +
  xlab("Mapped reads")
```

(ref:region-length) Length distribution for each region extracted from long amplicons.  Filtering limits are shown as dashed vertical lines.

```{r region-lengths, fig.cap = "(ref:region-length)", fig.height = 6}
baseregions <- c("ITS1", "5_8S", "ITS2", "LSU1", "D1", "LSU2", "D2", "LSU3", "D3",
               "LSU4")

region_limits <- dplyr::filter(regions, region %in% baseregions) %>%
  dplyr::mutate_at(
    "region",
    factor,
    levels = baseregions
    ) %>%
  tidyr::pivot_longer(
    cols = c("min_length", "max_length"),
    names_to = "limit",
    names_pattern = "(min|max)_length",
    values_to = "length"
  )
  

reads_table %>%
  dplyr::filter(region %in% baseregions,
         seq_run == "pb_500") %>%
  dplyr::mutate_at(
    "region",
    factor,
    levels = baseregions
    ) %>%
  ggplot(aes(length, weight = reads)) +
  stat_density(bw = 0.5, color = "#8da0cb", geom = "line") +
  geom_vline(data = region_limits,
             aes(xintercept = length),
             linetype = "dashed", alpha = 0.5) +
  facet_wrap(~region,ncol = 1, strip.position = "right", scales = "free_y") +
  scale_y_continuous(breaks = NULL, labels = NULL, name = "Read density") +
  scale_x_continuous(limits = c(0, 500), name = "Length (bp)")
```

(ref:ITS2-length) Comparison of the length of denoised ITS2 sequences extracted from different length amplicons and sequencing technologies.  *a*) Length distribution.  *b*) Empirical cumulative distribution function.

```{r ITS2-length, fig.cap = "(ref:ITS2-length)", fig.height = 6}
its2_dens <- reads_table %>%
  dplyr::left_join(dplyr::select(datasets, seq_run, tech)) %>%
  dplyr::filter(region == "ITS2") %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(
    amplicon = ifelse(seq_run == "pb_500", "Long", "Short") %>%
      factor(levels = c("Short", "Long")),
    reads = reads / sum(reads)
  ) %>%
  ggplot(aes(length, weight = reads, color = seq_run, group = seq_run)) +
  stat_density(bw = 0.5, geom = "line", position = "identity") +
  scale_color_brewer(type = "qual", guide = "none", palette = "Set2") +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = NULL) +
  facet_wrap(~tech + amplicon, ncol = 1, strip.position = "right", scales = "free_y")

its2_ecdf <- reads_table %>%
  dplyr::filter(region == "ITS2") %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(reads = reads / sum(reads)) %>%
  ggplot(aes(length, weight = reads, color = seq_run, group = seq_run)) +
  stat_ecdf(geom = "line") +
  scale_color_brewer(type = "qual", labels = c("Short amplicon - Ion", "Short amplicon - PacBio", "Long amplicon - PacBio"), name = NULL, palette = "Set2") +
  scale_y_continuous(name = "Cumulative read fraction") +
  scale_x_continuous(name = "ITS2 Length (bp)") +
  theme(legend.position = c(0.98, 0.02), legend.justification = c(1, 0))

ggpubr::ggarrange(its2_dens, its2_ecdf, ncol = 1, labels = "auto")
```

