---
title: "A Tale of Two Transects"
subtitle: "Also Two Sequencing Technologies, and Two Amplicons"
author: 
  - Brendan Furneaux^1^,
    Mohammad Bahram^1^,
    Anna Rosling^3^,
    Nourou S. Yorou^2^,
    Martin Ryberg^1^
  - ^1^Program in Systematic Biology,
    Department of Organismal Biology,
    Uppsala University,
    Uppsala, Sweden
  - ^2^Research Unit in Tropical Mycology and Plant-Fungi Interactions,
    LEB,
    University of Parakou,
    Parakou, Benin
  - ^3^Program in Evolutionary Biology,
    Department of Ecology and Genetics,
    Uppsala University,
    Uppsala, Sweden
date: "`r format(Sys.time(), '%B %d, %Y')`"
bibliography:
  - "all.bib"
  - "R.bib"
csl: molecular-ecology.csl
always_allow_html: true
output:
  bookdown::pdf_document2:
    fig_crop: yes
    keep_tex: yes
    latex_engine: lualatex
    includes:
      in_header: preamble.tex
  bookdown::word_document2: 
    keep_md: yes
---

```{r setup, include=FALSE}
library("knitr")
library("tikzDevice")
library("ggplot2")
library("magrittr")
library("tidyverse")
library("drake")
library("here")
library("phyloseq")
tryCatch(
  tinytex::tinytex_root(),
  error = function(e) tinytex::install_tinytex()
  )

knitr::opts_chunk$set(
  dev = "pdf",
  # dev.args = list(pointsize=32),
  echo = FALSE,
  # results = 'asis',
  # fig.show = 'asis',
  fig.width = 6,
  fig.height = 4.5,
  message = FALSE,
  warning = FALSE,
  external = TRUE
)
options(
  tikzDefaultEngine = "luatex",
  tikzXelatexPackages = c(options("tikzXelatexPackages")$tikzXelatexPackages,
                          "\\usepackage[version=4]{mhchem}\n",
                          "\\usepackage{siunitx}\n",
                          "\\DeclareSIUnit\\year{a}\n",
                          "\\usepackage{fontspec}"),
  tikzMetricsDictionary = here("writing/transect_paper-tikzDictionary")
)

base.dir <- regmatches(getwd(), regexpr(".*oueme-fungi-transect", getwd()))
if (opts_chunk$get("dev") == "tikz") {
  # styles$Expression <- styles$LaTeX.Expression
  # styles$Name <- styles$LaTeX.Name
  # styles$Short.Name <- styles$LaTeX.Short.Name
  # styles$Unit <- paste0("\\si{", styles$LaTeX.Unit, "}")
}
write_bib(c("base", "phyloseq", "gstat"), file = "R.bib", tweak = TRUE)

# use the "light" plan cache instead of the default cache at .drake
cache <- drake_cache(here(".light"))
readd <- function(..., cache = drake_cache(here(".light"))) {
  force(cache)
  drake::readd(..., cache = cache)
}
loadd <- function(..., cache = drake_cache(here(".light"))) {
  force(cache)
  drake::loadd(..., cache = cache, envir = parent.frame())
}

light_plan <- readRDS(here("data/plan/drake_light.rds"))
theme_set(theme_bw())

datasets <- read_csv(here("config/datasets.csv"), col_types = "cccccccicccccicc")
regions <- read_csv(here("config/regions.csv"), col_types = "cccciiiiic")

loadd(
  reads_table,
  region_table,
  asv_table,
  otu_table,
  demuxlength,
  demuxqual,
  readcounts,
  rawcounts,
  demuxcounts,
  regioncounts,
  cache = cache
)

source(here(file.path("scripts", "output_functions.R")))
```

# Introduction

## Introduction to ECM communities

Ectomycorrhizas (ECM) are a symbiosis between fungi and plant root tips.
The fungi provide nutrients and protection from pathogens in exchange for sugards from the plant [@Smith2010].
Approximately 8% of described fungal species [@ainsworth2008ainsworth;@Rinaldi2008] and 2% of land plant species [@Brundrett2017a] form ECM.
The plants include ecologically and economically important stand-forming trees belonging to both temperate/boreal groups such as Pinaceae and Fagaceae, and tropical groups such as Dipterocarpaceae, and Fabaceae tr. Amherstieae.

Although many well-known mushrooms are produced by ECM fungi (e.g., *Amanita*, *Cantharellus*, *Boletus*), many ECM fungi instead produce inconspicuous (e.g., *Tomentella*) or no (e.g., *Cenococcum*) fruit bodies.
Even when fruitbodies are large, they are ephemeral, so study of ECM communities is facilitated by looking at vegetative structures.
Unlike many saprotrophic fungi which grow easily in axenic culture, ECM fungi are usually difficult to culture, so DNA barcoding is increasingly used to investigate vegetative structures.
The advent of high-thoughput sequencing (HTS) has facilitated such studies by providing enough sequencing depth for metabarcoding of bulk environmental samples such as soils.

## Metabarcoding methods

As additional techniques and methods are developed for HTS, there is an increasing array of choices for researchers investigating fungal communities.
Traditionally, fungal metabarcoding studies have targetted the ITS1 or ITS2 regions, which provide sufficient resolution to distinguish fungal species in many groups, and which are usually short enough for HTS [@schoch2012;@Lindahl2013].
The resulting sequencing reads are clustered by sequence similarity to form operational taxonomic units (OTUs), which are then used as the units for further community analysis.
If taxonomic identification is desired, it has usually been performed by database searches using BLAST (ref).
This approach comes with some weaknesses.

While ITS1 and ITS2 often have suitable variation to distinguish species, they cannot be reliably aligned over the large taxonomic scales typically present in environmental samples.
Additionally the wide range of length variation of these regions may introduce bias in recovery of different taxa.
Further bias is introduced by variation in the 5.8S region which separates the two ITS regions, which makes it difficult to design primers that are suitable for all fungi [@tedersoo2015].
The recent advent of long-read HTS technologies such as Pacific Biosciences Single Molecule Real Time sequencing (PacBio) introduce the possibility of sequencing longer amplicons which include both the ITS regions and the flanking, more conserved SSU and/or LSU regions [@Tedersoo2018].
This has the potential to improve taxonomic placement of sequences without close database matches, and to allow the alignment of metabarcoding reads.
However, long-read technologies are currently more expensive per read, and so their use entails a trade-off with sequencing depth and/or sample number [@Kennedy2018].

Distance-based clustering conflates intra-species variation and sequencing error, and results are dataset-specific.
In contrast, more recent denoising methods such as DADA2 [@callahan2017], Deblur [@amir2017], and UNOISE2 [@edgar2016] utilize read quality information to control for sequencing error while leaving intra-species variation.
The resulting units are known as amplicon sequence variants (ASVs) or exact sequence variants (ESVs), as they should represent all true amplicon sequences from the sample.
Unlike cluster-based OTUs, ASVs can capture variation of as little as one base pair, and are not as dataset specific [@callahan2017].

Assignment of taxonomic identities using BLAST requires *a priori* choice of threshholds for different taxonomic ranks.
Several algorithms specifically designed for taxonomic assignment have been published which use information about variability within different taxa in the reference database to assign unknown sequences, along with confidence estimates for these assignments [e.g.,@wang2007;@edgar2016a;@murali2018a].
In addition, methods have been published which integrate predictions from multiple algorithms to increase the reliability of assignments [@somervuo2016;@gdanetz2017].

Phylogenetic information has the potential to both improve taxonomic assignment and provide alternative measures of community alpha and beta diversity.
Because OTU clustering may both "clump" different species in a single OTU, and "split" a single species into multiple OTUS [@ryberg2015], diversity measures based on counting species within a community or shared species between two communities may give different results depending on the clustering threshold.
In contrast, phylogenetic community distance measures like UNIFRAC [@wong2016] are relatively insensitive to species/OTU delimitation, but require a phylogenetic tree.
Phylogenetic placement algorithms [@matsen2010; @berger2011] are not easy to apply to ITS sequences because they require that the query sequences be aligned to a reference alignment.
Additionally, methods exist to place OTUs on a simplified tree based on taxonomic assignments [@tedersoo2018].
However, long amplicon sequencing allows the inclusion of alignable regions for construction of more fully resolved phylogenetic trees directly from metabarcoding reads.

We investigated the effects of different sequencing strategies and post-analysis on biological conclusions using measurement of the spatial community turnover rate along a transect in an ECM Soudanian woodland in Benin.

## Turnover scale in ECM forests

Turnover scale is the distance at which two communities can be considered to be independent samples of the local species pool.
Knowledge of turnover scale is import when planning studies of local diversity and its environmental correlates.
It varies between different ecosystems and taxonomic groups.
Turnover scale is often measured by the range at which Moran's I statistic indicates significant autocorrelation, or by fitting a function to an empirical distance-decay curve community dissimilarity vs. distance [@legendre2012].

Several studies have investigated the turnover scale in ECM forests, but so far they have been based on analysis of ECM root tips, rather than bulk soil.
@lilleskov2004 found autocorrelation only at ranges <2.6 m at most sites in temperate forests, based on Sanger sequencing.
Similarly, @pickles2012a found autocorrelation at distances <3.4 m, also in temperate forests, based on T-RFLP.
Two studies have included data from tropical African woodlands and wooded savannahs.
@tedersoo2011 found autocorrelation at ranges <10 m in Miombo woodland based on Sanger sequencing.
However, this study was based on irregular sampling with a minimum spacing of 8 m, so this as the smallest distance class.
@Bahram2013 performed a meta-analysis of turnover scale in ECM communities, including data from Benin, where they found turnover range of 65 m based on distance-decay curves.
They concluded that the range of distance decay is greater in tropical forests than temperate forests.

We investigated turnover range in both the total fungal community and ECM community by metabarcoding of bulk soil, sampled at narrow intervals, over two years.
We compare three different sequencing platforms (PacBio RS II, Illumina MiSeq, Ion Torrent Ion S5), long and short amplicons, three different taxonomic assignment algorithms (RPP classifier, SINTAX, IDTAXA) and reference databases (Unite, Warcup, RDP), and two different community distance measures (Bray-Curtis vs. weighted UNIFRAC).
We also present new algorithms for dividing the rDNA into regions, combining denoising results from multiple regions, and incorporating phylogenetic information into taxonomic assignments.

# Methods

## Sampling

Sampling was conducted at two sites (Ang: N 9.75456° W 2.14064°; Gan: N 9.75678° W 2.31058 °) approximately 30 km apart in the _Forêt Reservée de l'Ouémé Supérieur_ (Upper Ouémé Forest Reserve) in central Benin.
Both locations were located in woodlands dominated by the ECM host tree _Isoberlinia doka_ (Caesalpinioideae).
At each site, 25 soil samples were collected along a linear transect at intervals of 1 m in May 2015.
One third of the sample locations (3-m spacing) were resampled one year later in June 2016.
For each sample, any coarse organic debris <!--Do you have any definition? Wider than 5 mm? MR--> was removed from the soil surface and a sample of approximately 5cm×5cm×5cm was extracted with a <!-- sterilized? -MR--> knife blade.
Each sample was sealed in a plastic zipper bag and homogenized by shaking and manually breaking apart soil aggregations.
Approximately 50 mg total of soil was collected from two locations in the homogenized soil sample and placed into a separate 2.0 mL microtube containing 750 mL of lysis buffer and lysis beads (Xpedition^TM^ Soil/Fecal DNA miniprep, Zymo Research Corporation, Irvine, California, USA) and lysed in the field using a handheld bead-beater (TerraLyser^TM^; Zymo Research Corporation).
<!--The remainder of each sample was dried at 40°C with an electric dehydrator within 24-48 hours of collection for bulk chemical analysis. -->

An additional sample was collected at every sampling location (1-m spacing) in 2016 using LifeGuard^TM^ Soil Preservation Solution (MO BIO, Carlsbad, CA; USA) for preservation, without field lysis.
Sequencing results for these samples were found not to be comparable with results preserved using the Xpedition^TM^ lysis buffer (Supplementary figure \@ref(fig:)), so these samples were not included in spatial analyses.
However, reads from these sequences were included in the full bioinformatics workflow, including ASV calling, OTU clustering, and phylogenetic trees.

<!-- ## Soil Chemistry

  - Need to get methods from Nourou
  - or just not use it?
  -->

## DNA extraction, amplification, and sequencing

After field lysis, DNA was extracted using the Xpedition^TM^ Soil/Fecal Prep kit (see above).
Samples preserved using LifeGuard were first centrifuged at 10000×g for 1 minute, after which the supernatant was removed and DNA was extracted from the remaining soil using the Soil/Fecal Prep kit as for the other samples.
DNA was quantified using fluorometrically using Quant-iT^TM^ PicoGreen^TM^ dsDNA (Thermo Fisher Scientific, Waltham, MA, USA) fluorescent indicator dye on a Infinite F200 plate spectrofluorometer (Tecan Trading AG, Männedorf, Switzerland) according to the manufacturer's protocol.

Two different fragments of the nuclear rDNA were amplified (Figure \@ref(fig:rDNA)).
The short amplicon (approximately 300 bp) included the full ITS2 region as well as parts of the flanking 5.8S and large subunit (LSU) rDNA, using gITS7 [@ihrmark2012] as the forward primer and a mix of ITS4 [@white1990amplification] and ITS4a [@urbina2016] as the reverse primer (hereafter, ITS4m).
The long amplicon (approximately 1500 bp) included approximately 12 bp at the 3' end of the small subunit (SSU) rDNA, the full ITS region including the 5.8S rDNA, and approximately 950 bp at the 5' end of the LSU, including the first three variable regions (Figure \@ref(fig:rDNA)), using ITS1 [@white1990amplification] as the forward primer and LR5 [@vilgalys1990] as the reverse primer.

The gITS7 primers for the short amplicon were indexed for multiplexing (**supp info**).
Amplification was performed by polymerase chain reaction (PCR) in 20µl reactions containing 200 µM dNTP mix, 250 µM indexed gITS7 primer, 150µM ITS4m, 2mM McCl_2_, 0.1 U *Taq* polymerase (Dream *Taq*, Thermo Fisher Scientific, Waltham, MA, USA) and 3--7 ng purified DNA in Dream *Taq* buffer.
The reaction conditions were 10 min at 95°, followed by 35 cycles of 60 s at 95°, 45 s at 56°, and 50 s at 72°, and finally 3 min at 72°.
Each reaction was conducted in three technical replicates to reduce the effect of PCR stochasticity, which were pooled after amplification.

(ref:rDNA) Portion of the rDNA showing the 5.8S rDNA, partial SSU and LSU rDNA (thick lines), and internally transcribed spacer (ITS) regions (thin black lines).  D1-3 (grey) represent the first three variable regions in LSU [@michot1984], while LSU1-4 (black) represent the conserved regions. Primer sites used in this study are indicated in red (forward primers) and blue (reverse primers), and the resulting amplicons are shown with green braces.

<!--If limited by space, this could be in supp, and then just described in text. -MR-->
```{tikz rDNA, fig.cap = "(ref:rDNA)", code = readLines("rDNA_amplicons.pgf"), fig.ext = "pdf"}

```

Both primers for the long amplicon were indexed for multiplexing (**supp info**).
PCR was performed as for the short amplicons, but with 500 µM of each of the two primers.
Reaction conditions were 10 min at 95°, 30 cycles of 45 s at 95°, 45 s at 59°, and 90 s at 72°, and finally 10 min at 72°.
Each reaction was performed in three technical replicates as for short amplicons.

Each PCR run also included a blank sample and a positive control consisting of freshly extracted DNA from a commercially purchased fruitbody of *Agaricus bisporus*.

Amplicons were purified using SPRI beads [@vesterinen2016] and quantified fluorometrically as above.
An aliquot of 100 ng of DNA from each sample (or the total PCR product if less than 100 ng) was pooled into two libraries each for long and short amplicons.
The first library contained all samples from 2016 plus one PCR blank and one positive control (68 total samples), and the second containes all samples from 2015 plus one PCR blank and one positive control (42 total samples).
Each library was sequenced using Single Molecule Real Time (SMRT) sequencing on a Pacific Biosciences (PacBio) RS II sequencer at the Uppsala Genome Center (UGC; Uppsala Genome Center, Science
for Life Laboratory, Dept. of Immunology, Genetics and Pathology, Uppsala University, BMC, Box 815, SE-752 37 UPPSALA, Sweden).
Short amplicon libraries were sequenced on two SMRT cells each, while long amplicon libraries were sequenced on four SMRT cells each.

Additionally the short amplicon libraries were combined and sequenced using an Ion S5  (Ion Torrent) sequencer using one 520 chip at UGC, and a MiSeq (Illumina Inc.) sequencer using v3 chemistry with a paired-end read length of 300 bp at the SNP&SEQ Technology Platform (Dept. of Medical Sciences, Uppsala University, BMC, Box 1432, SE-751 44 UPPSALA, Sweden).
The Illumina library was pooled with samples for another project, with one half of the reads from one lane devoted to this project.
  
## Bioinformatics

Circular consensus sequence (CCS) basecalls for PacBio sequences were made using `ccs` version 3.4 [@pacificbiosciences2019] using the default settings.
The resulting sequences, as well as the paired-end Illumina sequences, were demultiplexed and sequencing primers were removed using `cutadapt` version 2.8 [@martin2011].
Sequencing primers were similarly removed from the Ion Torrent sequences, but interference between the tagged gITS7 primers and the Ion XPress tags used in library prep made full demultiplexing of the Ion Torrent sequences impossible.
For Ion Torrent and PacBio, reads were discarded if they did not have the appropriate primers on both ends.
Reads were searched in both directions, and reads where the primers were found in the reverse direction were reverse complemented before further analysis.
For Illumina sequences, primers were also searched for and removed on the 3' ends of the reads, in case of readthrough with short amplicons.
Read pairs were retained when PCR primers were detected at the 5' ends of both the forward and reverse read.
Read pairs where the primers were found in reverse orientation were kept in seperate files, but were retained in their original orientation until after denoising.

### Denoising

Forward and reverse Illumina reads were quality controlled (truncation after first base with quality <= 10, and then max 3 expected errors in either read) and denoised using `DADA2`.
Forward and reverse reads were denoised using seperate error models and then merged.

We attempted to denoise both long and short PacBio amplicons using `DADA2` version `r packageVersion("dada2")` [@callahan2016; @callahan2019] according to the steps outlined in  the supplementary information in @callahan2019.
However, only `r readd(region_table)$ASVs[readd(region_table)$region=="long"]` amplicon sequence variants (ASVs) were obtained for the long amplicons, representing `r percent(readd(region_table)$reads[readd(region_table)$region == "long"]/as.integer(gsub(" ", "", readd(demuxcounts)["pb_500"])), format = "d")` of the trimmed reads.
We believe that this poor performance was due to a combination of long read length and low sequencing depth relative to community diversity.
The `DADA2` algorithm requires that the seed sequence of each ASV be represented by at least two error-free reads [@callahan2016].
If sequencing errors are uniformly distributed, then the probability that a given read will be error-free is $(1-\epsilon)^L$, where $\epsilon$ is the sequencing error rate and $L$ is the read length in base pairs.
Then the number of reads of a given sequence that would be required to obtain two error-free reads in expectation is $2/(1-\epsilon)^L$.
For the combination of long reads (median $L=`r demuxlength['pb_500']` \text{ bp}$ after trimming) and moderate error rate (mean $\epsilon= `r format(demuxqual['pb_500'], digits = 4)`$ based on ccs quality scores) for the long amplicon in this study, the expected number of reads required to achieve two error-free reads is `r format(as.integer(round(2/(1 - demuxqual['pb_500'])^demuxlength['pb_500'])), big.mark = " ")`.
Given the high diversity relative to sequencing depth in this study (`r region_table$ASVs[region_table$seq_run == "pb_483" & region_table$region == "short"]` ASVs based on PacBio short amplicons, `r demuxcounts["pb_500"]` trimmed long amplicon reads), this requirement could not have been met for the long amplicons except by the most abundant sequences.
In comparison, the equivalent requirement for the short amplicon ($L=`r demuxlength['pb_483']` \text{ bp}$, $\epsilon=`r demuxqual['pb_483']`$) is only `r round(2/(1 - demuxqual['pb_483'])^demuxlength['pb_483'], 1)` reads.
We therefore developed a new workflow to assemble ASVs from the long amplicons, as follows:

Raw reads were divided into shorter regions by matching to covariance models (CM), which are similar to stochastic hidden markov models (HMM), but account for both nucleotide sequence and RNA secondary structure [@eddy1994].
First, the 5.8S rDNA was located in each read by searching for Rfam model RF0002 [@kalvari2018] using `cmsearch` from Infernal 1.1.2 [@nawrocki2013], and all bases before the 5.8S were assigned to ITS1.
No attempt was made to remove the approximately 12 bp fragment of the SSU from the 5' end of ITS1 in the long amplicons; it was too short to be reliably detected by a CM or the HMMs employed by ITSx [@bengtsson-palme2013].
<!--This approach was able to identify both the 5' and 3' ends of the 5.8S rDNA more consistently and quickly than ITSx [@bengtsson-palme2013, data not shown].-->
A reference alignment including conserved RNA base pairing between and within the 5.8S and relevant portions of LSU was generated from the fungal 28S RNA seed alignment from the Ribosomal Data Project (RDP) release 11.5 [@glockner2017; @cole2014] by truncating after the LR5 primer site and using the reference line to annotate the variable regions *sensu* @michot1984 and @raue1988.
A CM was generated from the alignment using `cmbuild` from Infernal.
The fragment of each read beginning with the 5.8S rDNA was then aligned to the CM using `cmalign` from Infernal.
The annotation line in the CM alignment for each read was then used to split the reads into alternating more-conserved and less-conserved regions as shown in Figure \@ref(fig:rDNA),
where LSU1-4 represent the conserved regions of LSU flanking the variable D1-3 regions [@michot1984].
For short amplicons, only (partial) 5.8S, ITS2, and (partial) LSU1 were extracted.
Code to extract the regions, including annotated seed alignments and CMs, is available in the new R package `LSUx`, available on github (https://github.com/brendanf/LSUx).

Each of the extracted regions was independently filtered for length (Table \@ref(tab:region-length)) and a maximum of three expected errors.
Sequences were then dereplicated and denoised into amplicon sequencing variants (ASVs) using `DADA2` version `r packageVersion("dada2")` [@callahan2016; @callahan2019].
The error model for `DADA2` denoising was fit using the 5.8S region for long amplicons, and using the entire read for short amplicons.
Independent error models were fit for each sequencing run (i.e., long *vs.* short amplicons, different sequencing technologies).
For PacBio libraries, `DADA2` was run with complete pooling and a band size of 16.
For Ion Torrent libraries, pseudo-pooling and a band size of 32 were used, and the homopolymer gap penalty was set to -1, as recommended by the `DADA2` FAQ (https://benjjneb.github.io/dada2/faq.html).
Chimeras within each region were removed using `removeBimeraDenovoTable` from `DADA2`.

For each ITS2 ASV from the long amplicon data set, the denoised sequences for the other regions corresponding to the same sequencing reads were concatenated to form a set of full-length reads.
For reads which were not assigned a denoised sequence for each region, the raw read for the region was used instead.
Because ITS2 is the most variable of the amplified regions (Supplementary Figure \@ref(fig:regions)), reads with identical ITS2 regions are expected have highly similar sequences in the other regions, unless the amplicon was chimeric.
The concatenated ASVs representing each long read were aligned in R using the `DECIPHER` package [@wright2015].
Outlier sequences, as determined by mean pairwise distance from the rest of the alignment, were removed from each alignment using the `odseq` package [@jehl2015], using the default threshold of 0.025.
The consensus of the remaining aligned sequences was assigned as the full-length ASV sequence.
Full-length ASV sequences with more than three ambiguous bases (i.e., no nucleotide >50% at a given position) were removed *(how many)*.
The count and sample distribution of reads assigned to each ASV were calculated in order to form a sample x ASV community matrix.
A similar process was used to generate a consensus ITS (ITS1--5.8S--ITS2) and LSU (LSU1--D1--LSU2--D2--LSU3--D3--LSU4) sequence for each ASV.
The process of assigning consensus full-length ASVs was carried out using the new `tzara` package for R, available on github (https://github.com/brendanf/tzara).

### Taxonomy assignment

Taxonomic annotations of the Ribosomal Data Project's LSU fungal training set (RDP) version 11.5 [@cole2014] and Warcup ITS training set [@wang2007] were mapped to the taxonomic classification system used in the Unite database version 8 [@nilsson2019a].
In particular, the classification for fungi was according to @tedersoo2018, and for non-fungal eukaryotes was according to the proposed system of @tedersoo2017c.
Although the latter system is not formally published, it is consistent with the annotations for non-fungal eukaryotes in the Unite database.
Additionally, it is a system with both purportedly monophyletic taxa and a uniform set of taxon ranks, which make it more appropriate for sequence-based taxonomic assignment algorithms than more accepted classification systems such as that of the International Society of Protistologists [ @adl2019], which utilizes hierarchical nameless ranks.
FASTA format files of the re-annotated RDP and Warcup training sets are available at (*somewhere*).

Taxonomic assignment was performed to genus level separately on the ITS and LSU regions using Unite/Warcup and RDP, respectively, as taxonomic references.
For each region/reference combination, taxonomy was assigned using three algorithms:
the RDP Naïve Bayesian Classifier (RDPC) as implemented in DADA2;
SINTAX [@edgar2016a] as implemented in VSEARCH v2.9.1 [@rognes2016];
and IDTAXA [@murali2018].
Each ASV was thus given up to nine preliminary taxonomic assignments (three references $\times$ three algorithms).

Sequences were assigned as ECM based on taxonomic assignments using the FUNGuild database [@nguyen2016funguild] via the R package `FUNGuildR` (https://github.com/brendanf/FUNGuildR).
All taxa which included "Ectomycorrhiza" in the guild assignment at any level of confidence were included.

### Clustering

For comparison with clustering-based methods, ASVs were clustered into operational taxonomic units (OTUs) at 97% similarity using VSEARCH v2.9.1 [@rognes2016].

### Alignment and phylogenetic inference

Unique LSU regions from long amplicon ASVs were aligned using DECIPHER [@wright2015] with up to 10 iterations of progressive alignment and conserved RNA secondary structure calculation and 10 refinement iterations.
<!-- The LSU tree ends up not looking as nice as the tree which includes ITS (I don't know why, except that maybe 5.8S is more helpful than ITS is harmful?) so I'm using that. Maybe I don't need to mention the LSU-only tree.-->
This alignment was truncated at a position after the D3 region corresponding to base 907 of the *Saccharomyces cerevisiae* S288C reference sequence for LSU, because several sequences had type 1 introns
<!-- Just curious, what are Type 1 introns -AR--> <!-- It has to do with the enzyme that cuts them out, I think, but I don't actually know my introns are Type 1, just that this is a location where Type 1 introns are known to occur. -BF-->
after this position [@holst-jensen1999].
Full length long amplicon ASVs (including ITS1, 5.8S, and ITS2 regions) were aligned and truncated in the same way.

ML trees were produced using RAxML version 8.2.12 [@stamatakis2014] using the GTR+GAMMA model and rapid bootstrapping with the MRE_IGN stopping criterion.
The LSU tree was not constrained topologically, but the long amplicon tree was constrained by the result for the LSU tree.
*Trees and alignments are available in Treebase. (not yet)*

The tree was rooted outside the Fungi by using the most abundant ASV which was confidently assigned to a non-fungal kingdom by all 6 applicable taxonomic assignment methods.
Assignments based on Warcup were not used at this step because non-Fungi are not included in the dataset.
The kingdom Fungi was identified as the minimal clade containing all ASVs which were confidently identified (consensus of at least 6 of 9 assignments) to a fungal phylum.
ASVs falling outside this clade were not included in the fungal community analysis.

Taxonomic assignments of ASVs from the long amplicon dataset were refined using the phylogenetic tree (Supplementary Figure \@ref(fig:phylotax)).
A taxon at a particular rank was assigned to a node and all its descendents if that taxon was consistent with the reference-based taxonomic assignments for each of the descendents.
A taxon assignment was considered to be consistent if at least one algorithm assigned that taxon at greater than 50% confidence, or if no algorithm successfully classified the sequence at greater than 50% confidence.
The result of this process was to give a taxonomic assignment to ASVs which were previously unassigned if they were nested within a clade where which was consistently given an assignment, as well as clarify the assignment of ASVs where different algorithms had resulted in different assignments, but only one of these was consistent with the assignments of other ASVs in the same clade.
This refinement algorithm is referred to as "PHYLOTAX".

ASVs from the short amplicon datasets were refined using only the final strict consensus step, i.e., an assignment at a given rank was accepted if there was no conflict between the different assignment algorithms at greater than 50% confidence.
This refinement method is referred to as "Consensus".
Additionally, a hybrid method, was applied to the short amplicon datasets, in which assignments from PHYLOTAX were used for ASVs which could be linked by an identical ITS2 region to a long amplicon, and assignments from Consensus were used for the remaining ASVs.

## Spatial analysis

Ecological community dissimilarity matrices were calculated using the ASV/OTU based Bray-Curtis metric (both long and short amplicons) and the phylogenetically based weighted UNIFRAC method (only long amplicons) in `phyloseq` version `r packageVersion("phyloseq")`.
Each of these distance matrices was used to calculate a Mantel correlogram for distances of 0--12 m.
Separate correlograms were drawn for samples taken during the same year, and samples separated in time by one year, in order to assess the degree to which the soil community changes over the course of one year.

Additionally, empirical variograms were generated by plotting mean community dissimilarity as a function of spatial distance and temporal separation, and fit using a joint exponential spatio-temporal model using the `fit.StVariogram` function from `gstat` version `r packageVersion("gstat")` [@R-gstat].
The mean dissimilarity between samples taken in different transects (distance $\approx$ 30 km) was also included as a single point for each year for the purposes of fitting the variogram function.

# Results

The number of sequencing reads and ASVs at each stage in the bioinformatics pipeline are shown in Table \@ref(tab:bioinfo).
Long (short) amplicon sequencing with PacBio yielded `r rawcounts["pb_500"]` (`r rawcounts["pb_483"]`) circular consensus reads, of which `r demuxcounts["pb_500"]` (`r demuxcounts["pb_483"]`) were successfully demultiplexed.
The 5.8S region was detected in `r regioncounts["pb_500"]` (`r regioncounts["pb_483"]`) reads.
Ion Torrent sequencing yielded `r demuxcounts["is_057"]` demultiplexed reads, with the 5.8S region detected in `r regioncounts["is_057"]`.

### Region extraction

(ref:readcounts) Number of Amplicon Sequence Variants (ASV) and reads at different pipeline stages.
*Raw*: raw reads as delivered by sequencing center;
*Trim*: reads with primers and demultiplexing barcodes removed;
*LSUx*: reads with a positive CM hit for 5.8S, allowing regions to be extracted;
*ITS2*: ASVs obtained for the ITS2 region, and reads successfully mapped to an ITS2 ASV;
*short*, *ITS*, *LSU*, *long*: ITS2-based ASVs mapped to consensus ASVs for longer regions, where \"short\" and \"long\" denote the full-length short and long amplicons, respectively.
Short amplicons were mapped to full ITS, LSU, and long amplicon ASVs when they had a perfect match in the ITS2 region.

```{r bioinfo}
#TODO add filtered reads (currently inflated numbers for non-Illumina)
#TODO asterisks for mapped ASVs
# loadd(bioinf_table)
options(knitr.kable.NA = '–')

readd(bioinf_table) %>%
  set_names(gsub(".*_", "", names(.))) %>%
  kable(
    booktabs = TRUE,
    caption = "(ref:readcounts)",
    align = "rrrrrr",
    format.args = list(big.mark = " "),
    linesep = c(rep("", 3), rep("\\addlinespace", 2), rep("", 4)),
    escape = FALSE
    ) %>%
  kableExtra::add_header_above(
    header = c(
      " " = 1,
      readd(bioinf_header)$amplicon[c(TRUE, FALSE)] %>% set_names(rep(2, length(.)), .)
    )
  ) %>%
  kableExtra::add_header_above(
    header = c(
      " " = 1,
      rle(readd(bioinf_header)$tech) %$% set_names(lengths, values)
    )
  )
```


### Reproducibility of read counts from different technologies

(ref:venn-table-asv) Correspondences between ASVs found by different sequencing strategies.
Each row shows the number of ASVs (*ASVs*) shared uniquely by one or more datasets, including the fraction of total ASVs for each dataset (*ASV frac*), the number of reads represented by those ASVs in each dataset (*reads*) and the fraction of total reads for the dataset (*frac*).

```{r venn-table-asv}
readd(venn_ASV) %>%
venn_table(ASVs, "(ref:venn-table-asv)")
```


(ref:venn-table-otu) Correspondences between 97% OTUs found by different sequencing strategies.
Each row shows the number of OTUs (*OTUs*) shared uniquely by one or more datasets, including the fraction of total OTUs for each dataset (*OTU frac*), the number of reads represented by those OTUs in each dataset (*reads*) and the fraction of total reads for the dataset (*frac*).

```{r venn-table-otu}
readd(venn_OTU) %>%
venn_table(OTUs, "(ref:venn-table-otu)")
```

(ref:venn) Venn diagrams showing shared ITS2-based ASVs (left) and 97% OTUs (right) between different sequencing strategies.
In each region, the number of ASVs/OTUs is given above, while the fractions of reads for each sequencing strategy are shown below.

```{r venn, fig.cap = "(ref:venn)", out.height = "30%", fig.show="hold"}
readd(vennplot_ASV) %>% {
  plot(
    select(., set, ASVs) %>% deframe() %>% replace_na(0) %>% eulerr::venn(),
    legend = list(
      labels = c("PacBio Long", "PacBio Short", "Ion Torrent", "Illumina")
    ),
    quantities = .$label,
    main = "ASV"
  )
}

readd(vennplot_OTU) %>% {
  plot(
    select(., set, OTUs) %>% deframe() %>% replace_na(0) %>% eulerr::venn(),
    legend = FALSE,
    labels = FALSE,
    quantities = .$label,
    main = "OTU"
  )
}

```

(ref:readcap) Comparison between read numbers for different sequencing strategies, by ASV (top) and 97% OTU (bottom). ASVs/OTUs which were detected by one sequencing strategy but not the other are plotted as tick marks along the axes. Dashed line represents a constant ratio of read numbers. The blue line is a LOESS smooth of the data, with associated uncertainty in grey shading. $R^2$ value displayed is for log-transformed non-zero read numbers.

```{r pb-vs-it, fig.cap="(ref:readcap)", fig.height=8}
ggpubr::ggarrange(
  read_comparison(
    readd(multi_table),
    readd(comparisons),
    type = "ASV"
  ),
  read_comparison(
    readd(multi_table),
    readd(comparisons),
    type = "OTU"
  ),
  ncol = 1,
  labels = "auto",
  label.x = 0.9
)
```

The number of ASVs and OTUs shared between the different sequencing strategies are shown in Tables \@ref(tab:venn-table-asv) and \@ref(tab:venn-table-otu), respectively, and graphically in figure \@ref(fig:venn).
ASVs shared between all datasets represented `r text_list(percent(readd(venn_ASV)["1111", c("frac_pb_500", "frac_pb_483", "frac_SH-2257", "frac_is_057")]))` of the reads for the long and short PacBio datasets, Illumina dataset, and Ion Torrent dataset, respectively.
These fractions increased to `r text_list(percent(readd(venn_OTU)["1111", c("frac_pb_500", "frac_pb_483", "frac_SH-2257", "frac_is_057")]))` when differences at the intra-species scale were removed by clustering the ASVs into 97% OTUs.
In particular, `r text_list(percent(colSums(mutate_all(readd(venn_OTU)[c("0111", "1111"), c("frac_pb_483", "frac_SH-2257", "frac_is_057")], as.numeric), na.rm = TRUE)))` of reads in the PacBio, Illumina, and Ion Torrent short-amplicon datasets belonged to OTUs shared between all three datasets.
In contrast, `r percent(readd(venn_ASV)["1000", "frac_pb_500"])` of reads in the long PacBio dataset belonged to ASVs which were unique to that dataset, and the fraction only reduced to `r percent(readd(venn_OTU)["1000", "frac_pb_500"])` after OTU clustering.


Figure \@ref(fig:pb-vs-it) shows the correspondence between the read count for different ASVs/OTUs in the different technologies, where shared ASVs/OTUs are plotted as circles, and unshared OTUs are plotted on the margins.
In all cases, the read counts for shared ASVs/OTUs were correlated ($R^2 = `r compR2("SH-2257", "is_057", "OTU")`$).
Correlations between read counts for the three technologies using the short amplicon library were increased by OTU clustering
(`r compR2("pb_483", "SH-2257", "ASV")` to `r compR2("pb_483", "SH-2257", "OTU")`,
`r compR2("pb_483", "is_057", "ASV")` to `r compR2("pb_483", "is_057", "OTU")`, and
`r compR2("SH-2257", "is_057", "ASV")` to `r compR2("SH-2257", "is_057", "OTU")`,
for PacBio vs. Illumina, PacBio vs. Ion Torrent, and Illumina vs. Ion Torrent, respectively),
but this was not, or only weakly, the case for correlations between the long amplicon library and short amplicon library
(`r compR2("pb_500", "pb_483", "ASV")` to `r compR2("pb_500", "pb_483", "OTU")`,
`r compR2("pb_500", "SH-2257", "ASV")` to `r compR2("pb_500", "SH-2257", "OTU")`, and
`r compR2("pb_500", "is_057", "ASV")` to `r compR2("pb_500", "is_057", "OTU")`, for PacBio long amplicon reads vs PacBio, Illumina, and Ion Torrent short reads, respectively).

## Taxonomic assignment

The fraction of reads and ASVs assigned to each taxonomic rank is shown in Figure \@ref(fig:tax-chart).
For all sequencing datasets and taxonomic assignment protocols, a higher proportion of reads was assigned than of ASVs, indicating that common ASVs were more likely to be identified than rare ASVs.
A greater fraction of ITS reads and ASVs were assigned using the Unite database than the Warcup database across sequencing technologies, amplicons, algorithms, and taxonomic ranks.
Across sequencing technologies, amplicons, and reference databases, the RDPC algorithm assigned the greatest fraction of reads and ASVs, followed by SINTAX, and then IDTAXA, with the exception of lower taxonomic ranks (order for the Long amplicon, family and genus for both amplicons) using the warcup reference database, where SINTAX assigned the greatest fraction of reads, but not ASVs.

(ref:tax-chart) Fraction of ASVs (left) and reads (right) assigned to each taxonomic rank, for different sequencing technologies (PacBio RS II, Ion Torrent Ion S5), amplicons (Long, Short), reference databases (Unite, Warcup, RDP), and assignment algorithms (PHYLOTAX, Consensus, RDPC, SINTAX, IDTAXA).
Consensus and PHYLOTAX assignments are based on the consensus of RDPC, SINTAX, and IDTAXA, using all available databases and, in the case of PHYLOTAX, phylogenetic information.
They are plotted in each column to compare with results for the individual databases.

```{r tax-chart, fig.cap = "(ref:tax-chart)"}
readd(tax_chart)
```

(ref:taxa) Heat tree summarizing taxonomic composition of soil community.
Color and size of nodes represent the fractional read abundance of all ASVs belonging to that taxonomic group.
Color and thickness of branches represent the fractional ASV richness of that taxonomic group.
Both measures are a mean across sequencing runs, reference databases, and taxonomic assignment algorithms.
Diverse but relatively rare groups are thus shown as small, light-colored nodes on relatively thick, darker-green-colored branches (e.g., Dothideomycetes), while common but relatively non-diverse groups are shown as large nodes on relatively thin branches (e.g., Russulales).
Groups which are not represented by at least 1% of reads or 1% of ASVs in any dataset are collapsed into nodes labeled "*".
ASVs which could not be further assigned are labelled "?".

```{r taxa, fig.cap = "(ref:taxa)", out.width="100%", fig.width = 8}
fungi_read <- readd(taxdata) %>%
  taxa::filter_taxa(
    taxon_names == "Fungi",
    reassign_obs = FALSE,
    reassign_taxa = FALSE
    ) %>%
  extract2("data") %>%
  extract2("tax_read") %>%
  select(ends_with("PHYLOTAX")) %>%
  set_names(names(.) %>% str_extract("(PacBio|Illumina|Ion.Torrent)_(Long|Short)")) %>%
  unlist()

fungi_asv <- readd(taxdata) %>%
  taxa::filter_taxa(
    taxon_names == "Fungi",
    reassign_obs = FALSE,
    reassign_taxa = FALSE
    ) %>%
  extract2("data") %>%
  extract2("tax_asv") %>%
  select(ends_with("PHYLOTAX")) %>%
  set_names(names(.) %>% str_extract("(PacBio|Illumina|Ion.Torrent)_(Long|Short)")) %>%
  unlist()

ecm_counts <- readd(taxon_reads) %>%
  filter(Algorithm == "PHYLOTAX") %>%
  group_by(seq_run) %>%
  mutate(ASVs = 1/n()) %>%
  filter(ECM %in% c("Possible ECM", "Probable ECM", "Highly Probable ECM")) %>%
  summarize_at(c("ASVs", "reads"), sum)

ecm_read <- select(ecm_counts, seq_run, reads) %>% deframe()
ecm_asv <- select(ecm_counts, seq_run, ASVs) %>% deframe()

set.seed(2)
theme <- theme_update(panel.border = element_blank())
readd(taxdata) %>%
  metacoder::heat_tree(
    layout = "davidson-harel",
    # initial_layout = "reingold-tilford",
    node_size = rowMeans(.$data$tax_read[,-1]),
    node_color = rowMeans(.$data$tax_read[,-1]),
    node_label = replace_na(taxon_names, "unknown"),
    node_size_range = c(0.002, .035),
    node_size_axis_label = "Read abundance",
    node_color_axis_label = "Read abundance",
    node_label_size_range = c(0.01, 0.03),
    edge_size = rowMeans(.$data$tax_asv[,-1]),
    edge_size_trans = "linear",
    edge_size_axis_label = "ASV count",
    edge_size_range = c(0.001, 0.03),
    edge_color = rowMeans(.$data$tax_asv[,-1]),
    edge_color_axis_label = "ASV count",
    # aspect_ratio = 3/2,
    make_node_legend = FALSE,
    make_edge_legend = FALSE,
    output_file = here("temp/heattree.pdf")
  )
theme_set(theme)
```

Taxonomic composition of the sequenced soil community is summarized in Figure \@ref(fig:taxa).
According to the PHYLOTAX assignments, Fungi represented `r percent(fungi_read["PacBio_Long"], format = "f", digits = 1)` of the reads and `r percent(fungi_asv["PacBio_Long"], format = "f", digits = 1)` of the ASVs in the long amplicon library, compared to `r paste(percent(range(fungi_read[c("PacBio_Short", "Illumina_Short", "Ion.Torrent_Short")]), format = "f", digits = 1), collapse = "–")` of the reads and `r paste(percent(range(fungi_asv[c("PacBio_Short", "Illumina_Short", "Ion.Torrent_Short")]), format = "f", digits = 1), collapse = "–")` of the ASVs in the short amplicon library.
Fungi categorized as ECM made up `r percent(ecm_read["pb_500"], format = "f", digits = 1)` of reads and `r percent(ecm_asv["pb_500"], format = "f", digits = 1)` of ASVs in the long amplicon library, and `r paste(percent(range(ecm_read[c("pb_483", "SH-2257", "is_057")]), format = "f", digits = 1), collapse = "–")` of the reads and `r paste(percent(range(ecm_asv[c("pb_483", "SH-2257", "is_057")]), format = "f", digits = 1), collapse = "–")` of the ASVs in the short amplicon library.
Assignment to kingdom Fungi and ECM status for different amplicons, sequencing technologies, reference databases, and algorithms are shown in Supplementary Figure \@ref(ref:ecm).

(ref:heattree-db-compare) Variation in read abundance and diversity for different amplicons across the taxonomic tree.
Red nodes/edges represent increased read/ASV count for the short amplicon library, while teal nodes/edges represent increased read/ASV count for the long amplicon library.
Values are log_2_ of the ratio of median values across all datasets (sequencing technology, reference database, assignment algorithm) for each amplicon.

```{r heattree-db-compare, fig.cap = "(ref:heattree-db-compare)", include = FALSE}
taxdata2 <- readd(taxdata)
# taxdata2$data$asv_table <- metacoder::calc_obs_props(taxdata2, "tax_data", cols = asv_cols)
# taxdata2$data$read_table <- metacoder::calc_obs_props(taxdata2, "tax_data", cols = read_cols)
# taxdata2$data$tax_asv <- metacoder::calc_taxon_abund(taxdata2, "asv_table", cols = asv_cols)
# taxdata2$data$tax_read <- metacoder::calc_taxon_abund(taxdata2, "read_table", cols = read_cols)
taxdata2$data$diff_read <- metacoder::compare_groups(
  taxdata2,
  data = "tax_read",
  cols = names(taxdata2$data$tax_read) %>%
    keep(str_detect, "reads_PacBio_Long_(Unite|RDP)"),
  groups = names(taxdata2$data$tax_read) %>%
    keep(str_detect, "reads_PacBio_Long_(Unite|RDP)") %>%
    str_replace("reads_.+_.+_(.+)_.+", "\\1"),
  func = function(abund1, abund2) {
    list(read_ratio = log10(mean(abund1) / mean(abund2)))
  }
  )
taxdata2$data$diff_asv <- metacoder::compare_groups(
  taxdata2,
  data = "tax_asv",
  cols = names(taxdata2$data$tax_asv) %>% keep(startsWith, "ASVs_"),
  groups = names(taxdata2$data$tax_asv) %>%
    keep(startsWith, "ASVs_") %>%
    str_replace("ASVs_.+_(.+)_.+_.+", "\\1"),
  func = function(abund1, abund2) {
    list(asv_ratio = log10(mean(abund1) / mean(abund2)))
  }
)

taxdata2 <- taxdata2$filter_taxa(!is.nan(asv_ratio), !is.nan(read_ratio),
                                 reassign_obs = FALSE)

set.seed(2)
theme <- theme_update(panel.border = element_blank())
taxdata2 %>%
  metacoder::heat_tree(
    layout = "davidson-harel",
    initial_layout = "reingold-tilford",
    
    node_size = rowMeans(.$data$tax_read[,-1]),
    node_size_range = c(0.005, .035),
    node_size_axis_label = "Read abundance",
    
    node_color = read_ratio,
    node_color_range = metacoder::diverging_palette(),
    node_color_trans = "linear",
    node_color_axis_label = "Read abundance ratio",
    node_color_interval = c(-4.5, 4.5),
    
    edge_size = rowMeans(.$data$tax_asv[,-1]),
    edge_size_range = c(0.0025, 0.03),
    edge_size_trans = "linear",
    edge_size_axis_label = "ASV count",
    
    edge_color = asv_ratio,
    edge_color_range = metacoder::diverging_palette(),
    edge_color_trans = "linear",
    edge_color_axis_label = "ASV count ratio",
    edge_color_interval = c(-3, 3),
    
    node_label = ifelse(
      pmax(abs(.$data$diff_read$read_ratio),
           abs(.$data$diff_asv$asv_ratio)) > 0.5,
      taxon_names,
      ""
    ),
    node_label_size_range = c(0.010, 0.03),
    # title = unique(paste(.$data$diff_read$treatment_1, "vs.", .$data$diff_read$treatment_2)),
    aspect_ratio = 3/2
  )
theme_set(theme)
```


### Positive control

*Agaricus bisporus*, the positive control, was represented by a single ASV in the positive control samples for both long- and short-amplicon PacBio datasets, and in the Ion Torrent dataset.
Additional ASVs belonging to the genus *Agaricus* were also detected in the same wells as the positive control in the Ion Torrent dataset, but these were sufficiently different that they probably represent additional *Agaricus* species from the field samples, and were found in the same wells due to incomplete demultiplexing.
*A. bisporus* was represented by two ASVs in the Illumina dataset, which differed at one base pair.
The abundance of the second ASV was `r readd(agaricus_reads) %>% as.data.frame() %>% {.[["f2ab49e8"]]/.[["39d80c19"]]} %>% keep(~. > 0) %>% percent(format = "f", digits = 2) %>% paste(collapse = " and ")` that of the primary ASV in the two Illumina positive controls.
The consistency of this ratio across PCR replicates suggests that it represents true inter-copy variation within the specimen, rather than sequencing or PCR error.

The primary *A. bisporus* ASV was the most abundant ASV in the long-amplicon PacBio dataset and the Ion Torrent dataset, and the fifth most abundant ASV in the short-amplicon PacBio dataset, and the third most abundant ASV in the Illumina dataset.
This ASV was also found in `r readd(pos_control_data) %>% filter(!is.na(pc_frac)) %>% group_by(seq_run) %>% summarize(well_frac = sum(pc_frac > 0) / n()) %>% deframe() %>% magrittr::extract(c("pb_500", "pb_483", "SH-2257", "is_057")) %>% percent(format = "f", digits = 1) %>% text_list()` of the non-control samples, and represented `r readd(pos_control_data) %>% filter(complete.cases(.)) %>% group_by(seq_run) %>% summarize(read_frac = sum(pc_reads) / sum(all_reads)) %>% deframe() %>% magrittr::extract(c("pb_500", "pb_483", "SH-2257", "is_057")) %>% percent(format = "f", digits = 2) %>% text_list()` of non-control reads, in the PacBio long, PacBio short, Illumina, and Ion Torrent datasets, respectively.

## Spatial analysis

(ref:correlog-cap) Mantel correlograms showing the correlation between Bray-Curtis (top three rows) or weighted Unifrac (bottom row) dissimilarities and spatial distance, for short (top two rows) and long (bottom two rows) amplicons, and for the entire soil fungal community (left) or only ECM taxa (right).  Unifrac distance was not calculated for short amplicons because it requires that the sequences are placed on a phylogenetic tree.

```{r correlog, fig.cap="(ref:correlog-cap)"}
light_plan %>%
  filter(startsWith(target, "correlog")) %>%
  select(target) %>%
  separate(
    target,
    into = c("step", "guild", "metric", "tech", "amplicon", "method", "tdist"),
    sep = "_",
    remove = FALSE
  ) %>%
  filter(startsWith(method, "PHYLOTAX")) %>%
  mutate(
    tdist = paste(tdist, "year"),
    guild = plyr::mapvalues(guild, c("fungi", "ecm"), c("all Fungi", "ECM")),
    metric = plyr::mapvalues(metric, c("bray", "wunifrac"), c("Bray-Curtis", "W-UNIFRAC")),
    amplicon = factor(amplicon, levels = c("Short", "Long"))
  ) %>%
  mutate_at("target", purrr::map, readd, character_only = TRUE) %>%
  mutate_at("target", purrr::map, "mantel.res") %>%
  mutate_at("target", purrr::map, as.data.frame) %>%
  unnest(target) %>%
  filter(complete.cases(.)) %>%
  mutate(Significant = `Pr(corrected)` < 0.05) %>%
  ggplot(aes(class.index, Mantel.cor, group = tdist, color = tdist, shape = Significant)) +
  geom_point(size = 3) +
  geom_line(alpha = 0.3, size = 1.5) +
  geom_hline(yintercept = 0, linetype = 2, alpha = 0.5) +
  # geom_line(aes(y = exp(predict(bc_fit)))) +
  scale_y_continuous(name = "Mantel correlation") +
  scale_x_continuous(breaks = c(0, 3, 6, 9, 12)) +
  scale_color_discrete(name = "Time lag") +
  xlab("Distance (m)") +
  ggnomics::facet_nested(amplicon + tech + metric ~ guild, scales = "fixed", nest_line = TRUE) +
  scale_shape_manual(values = c("TRUE" = 16, "FALSE" = 1)) +
  theme(strip.background = element_blank())
```

Mantel correlograms of the Bray-Curtis and weighted UNIFRAC community dissimilarities with respect to spatial distance and time lag are shown in Figure \@ref(fig:correlog).
Results are qualitatively similar between the two amplicon libraries and between PacBio and Illumina sequencing, with significant autocorrelation ($p < 0.05$, filled red circles) in the Bray-Curtis metric at ranges of up to 3m for the total fungal community, and 1–2m for the ECM community.
In both cases, the greatest correlation magnitudes and distances are associated with Illumina sequencing of the short amplicon library, followed by PacBio sequencing of the long amplicon library, with PacBio sequencing of the short amplicon library detecting the least spatial structure.

In contrast, the weighted UNIFRAC distance, which was only calculated for the long amplicon library, shows very little spatial structure, with only the total fungal community in the 1m 
distance class showing a significant correlation at $p < 0.05$.

The Bray-Curtis metric showed significant ($p < 0.05$) positive correlation at a time lag of 1 year and 0m separation (filled blue circles) for both the total fungal and ECM communities in the long amplicon library.
For the short amplicon library, although the general profile of the correlograms was similar, correlation at 0m and 1 year was not significant, but there was a negative correlation at time lag of 1 year and a distance of 1m for both sequencing technologies.
This negative correlation was significant in each short amplicon correlogram except for the ECM community sequenced by Illumina.

## Spatio-temporal variogram

Variograms relating community dissimilarities and spatial distances are shown in Figure \@ref(fig:spatio).
For the cases where the Mantel correlogram detected a significant positive correlation, the best-fit exponential curve is also displayed; for the long amplicon library, where there was also a significant positive correlation after a time lag of one year, the best fit curve for time lag is also included.
The best fit spatial and temporal ranges, along with a 95% confidence interval, are shown in \@ref(tab:variofit).
Although a model was fit for the weighted UNIFRAC distance applied to the total fungal community, the result was very poorly constrained, and a range of 0m was included in the 95% confidence interval.
Although the best fit spatial ranges vary between the different datasets by a factor of about 3, there is overlap of the 95% confidence intervals for all of the Bray-Curtis variograms across communities, amplicon libraries, and sequencing technologies.

(ref:spatio) Relationship between spatiotemporal distance and community dissimilarities.
Circles represent community data from short (top two rows) and long (bottom two rows) amplicon libraries, sequenced by Illumina MiSeq (top row) or PacBio RS II (bottom three rows).
Community dissimilarities are calculated using the Bray-Curtis dissimilarity for all datasets (top three rows) and using the weighted UNIFRAC dissimilarity for the long amplicon library, for which a phylogenetic tree could be constructed (bottom row).
The left column represents the full fungal community, and the right column only sequences identified as ECM.
The color of each circle represents the time lag between samples being compared (0 or 1 year), and the size represents the number of comparisons for that spatial distance and time lag.
Lines are the best-fit lines for an exponential decay to max model.
The model was only fit for datasets where the Mantel test indicated a significant relationship between community dissimilarity and spatial (for the 0 year timelag) or spatiotemporal (for the 1 year time lag) distance.

```{r spatio, fig.cap = "(ref:spatio)"}


readd(variog_empir) %>%
  filter(algorithm == "PHYLO") %>%
  ggplot(aes(dist, gamma, color = timelag, size = n)) +
  ggnomics::facet_nested(amplicon + tech + metric ~ guild, scales = "free", nest_line = TRUE, space = "free_y") +
  # geom_hline(data = variog_sills, aes(yintercept = sills), linetype = "dashed", color = "gray50") +
  # geom_vline(data = variog_data, aes(xintercept = range), linetype = "dashed", color = "gray50") +
  # geom_jitter(shape = 46, alpha = 0.5) +
  # geom_line(size = 1.5, alpha = 0.5) +
  geom_point(alpha = 0.5) +
  # geom_smooth(data = variog_points, aes(fill = timelag), color = FALSE, alpha = 0.5) +
  geom_line(data = filter(readd(variog_fit), timelag == "1", algorithm == "PHYLO"), size = 0.5, color = "darkcyan", alpha = 0.8) +
  geom_line(data = filter(readd(variog_fit), timelag == "0", algorithm == "PHYLO"), size = 0.5, color = "red1", alpha = 0.8) +
  scale_x_continuous(expand = expand_scale(0, 0), limits = c(0, 25), name = "Distance (m)") +
  scale_color_discrete(name = "Time lag") +
  scale_size_continuous(name = "Comparisons") +
  scale_y_continuous(name = "Community dissimilarity") +
  theme(strip.background = element_blank())
```

(ref:variofit) Parameters for variogram fits shown in Figure \@ref(fig:spatio-temporal). Range: range at which exponential function is at 95% of its maximum value.

```{r variofit, results="asis"}
variog_data %>%
  select(mantel_0, mantel_1, variofit_0 = variofit2, variofit_1 = variofitST2, metric, amplicon, tech, guild, algorithm) %>%
  pivot_longer(1:4, names_to = c(".value", "timelag"), names_sep = "_") %>%
  mutate(params = map(variofit, broom::tidy)) %>%
  unnest(params) %>%
  bind_cols(
    pmap_dfr(
      .,
      function(mantel, variofit, term, ...) {
        if (mantel) {
          tryCatch(broom::confint_tidy(object = variofit, parm = term) %>% as.list %>% inset2("term", term) %>% as.data.frame,
                   error = function(e) tibble(term = term, conf.low = NA_real_, conf.high = NA_real_))
        } else {
          tibble(term = term, conf.low = NA_real_, conf.high = NA_real_)
        }
      }) %>%
      select(-term)
  ) %>%
  filter(term %in% c("range", "timerange")) %>%
  mutate_at("conf.low", replace_na, 0) %>%
  mutate(value = ifelse(
    is.na(estimate) | is.na(conf.high),
    "-",
    sprintf("%.2g (%.2g–%.2g)", estimate, conf.low, conf.high)
  )) %>%
  filter(timelag == "0" | term == "timerange") %>%
  pivot_wider(names_from = "term", values_from = "value", id_cols = c("guild", "amplicon", "tech", "metric", "algorithm")) %>%
  select(Guild = guild, Amplicon = amplicon, Tech = tech, Algorithm = algorithm, Metric = metric, "Space Range (m)" = range, "Time Range (a)" = timerange) %>%
  arrange(Guild, Amplicon, Tech, Algorithm, Metric) %>%
  kable(booktabs = TRUE, caption = "(ref:variofit)", linesep = c(rep("", 5), "\\addlinespace"))
```

# Discussion

## Comparison of technologies

  - length bias not clearly observed between PacBio and Ion Torrent short reads
  - long reads had more very short ITS2 sequences Supplementary Figure \@ref(fig:ITS2-length)) -- these are mostly Alveolata (Supplementary Figure \@ref(fig:short-its))
  - lots of ASVs/OTUs detected in only one tech

  - very few PacBio OTUs undetected by Ion torrent/Illumina from same library; only rare OTUS undetected by PacBio -- sequencing depth seems to be the biggest effect.
  
  - sequencing technologies yield comparable results (given read depth) with sufficient clustering
  - not such good match with ASVs -- suggests DADA2 doesn't perform equally on different datasets
  
  - still lots of ASVs/OTUs detected by only one amplicon -- primer bias.

## Use of Phylogeny to improve taxonomic identification

  - Strict consensus usually increases the number of assigned sequences relative to any single method, except for family and genus level identifications.
  - Different methods and databases bring mostly complementary, non-contradictory information.
  - Unite (using full ITS) identifies a similar fraction of reads and ASVs as RDP using LSU.
  
## Differences in taxonomic bias of different amplicons
  - Long amplicon library includes more non-fungi, particularly Alveolates and Metazoans.
  - Also more of a few isolated fungal genera -- Tremellodendron, Marcelleina, Tulasnella.
  - Short amplicon recovers more Sordariomycetes, Saccharomycetes, Glomeromycota -- the latter two maybe due to sequencing depth.

## Bias in ecological results using different amplicons and sequencing technologies
  - UNIFRAC does not detect spatial structure within this relatively homogeneous community -- largest fraction of weighted branch length is between Ascomycota and Basidiomycota.
  - choice of PCR primer (and possibly PCR replicate?) is more important for repeatability that choice of sequencing technology.

# Acknowledgements

The authors would like to acknowledge support of the National Genomics Infrastructure (NGI) / Uppsala Genome Center and UPPMAX for providing assistance in massive parallel sequencing and computational infrastructure.
Work performed at NGI / Uppsala Genome Center has been funded by RFI / VR and and Science for Life Laboratory, Sweden.

# Bibliography {-}

<div id="refs"></div>

\processdelayedfloats

# Supplementary Information {-}

\beginsupplement

(ref:phylotax) Hypothetical example of phylogenetic refinement of taxonomic assignments.
In the example, a clade includes  seven OTUs (A-F), which have been identified by two methods as belonging to taxa "Tax1" or "Tax2", or are unidentified ("unk"), as shown in the tip labels.
No taxon is assigned at node 1, because one of the child branches (A) is completely unassigned.
No taxon is assigned at node 2, because the assignments at C and F are inconsistent.
Node 3 is assigned to Tax1 because this is consistent with at least one of the assignments for both B and C.
Node 4 (and thus also node 5) is assigned to Tax2 because this is consistent with at least one of the assignments for D and F, and because E is completely unassigned.

```{r phylotax, fig.height = 2, fig.width = 3, fig.cap = "(ref:phylotax)"}
extree <-
  treeio::as.treedata(ape::read.tree(text = "(A:1,((B:1,C:1):1,((E:1,F:1):1,D:1):1):1);")) %>%
  tidytree::full_join(
    tibble(label = LETTERS[1:6],
           tax1 = c("unk", "Tax1", "Tax2", "Tax2", "unk", "unk"),
           tax2 = c("unk", "Tax2", "Tax2", "Tax1", "unk", "Tax1")),
    by = "label"
  )
ggtree::ggtree(extree) +
  ggtree::geom_tiplab(x = 4, align = 2) +
  xlim(0, 6) +
  ggtree::geom_tiplab(
    aes(color = tax1, label = tax1),
    x = 4.7,
    hjust = 0.5
  ) +
  ggtree::geom_tiplab(
    aes(color = tax2, label = tax2),
    x = 5.7,
    hjust = 0.5
  ) +
  ggtree::geom_tiplab(x = 5.2, label = "/", hjust = 0.5) +
  ggtree::geom_nodelab(aes(label = node - 6), geom = "label") +
  ggtree::geom_hilight(node = 10, fill = "steelblue", extendto = 4) +
  ggtree::geom_hilight(node = 9, fill = "tomato", extendto = 4) +
  scale_color_manual(values = c(Tax1 = "steelblue", Tax2 = "tomato", unk = "grey50")) +
  scale_y_reverse()
```

(ref:full-length) Comparison of the length of sequences from different length amplicons and sequencing technologies.  Length distribution (*a*, *c*) and empirical cumulative distribution function (*b*, *d*) for short (*a*, *b*) and long (*c*, *d*) amplicons, respectively.

```{r full-length, fig.cap = "(ref:full-length)", fig.height = 6}
full_dens <- readd(reads_table) %>%
  dplyr::left_join(dplyr::select(datasets, seq_run, tech, amplicon)) %>%
  dplyr::filter(region %in% c("long", "short")) %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate_at("amplicon", factor, levels = c("Short", "Long")) %>%
  dplyr::mutate_at("tech", factor, levels = c("PacBio", "Illumina", "Ion Torrent")) %>%
  dplyr::mutate(
    reads = reads / sum(reads)
  )

full_dens_short <- full_dens %>%
  filter(amplicon == "Short") %>%
  ggplot(aes(length, weight = reads, color = tech, group = tech)) +
  stat_density(bw = 0.5, geom = "line", position = "identity") +
  scale_color_brewer(type = "qual", guide = "none", palette = "Set2") +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = NULL, labels = NULL, breaks = NULL) +
  ggnomics::facet_nested(rows = vars(tech), scales = "free_y") +
  theme(strip.background = element_blank())

full_dens_long <- full_dens %>%
  filter(amplicon == "Long") %>%
  ggplot(aes(length, weight = reads, color = tech, group = tech)) +
  stat_density(bw = 0.5, geom = "line", position = "identity") +
  scale_color_brewer(type = "qual", guide = "none", palette = "Set2") +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = NULL, labels = NULL, breaks = NULL) +
  ggnomics::facet_nested(rows = vars(tech), scales = "free_y") +
  theme(strip.background = element_blank())

full_ecdf <- readd(reads_table) %>%
  dplyr::filter(region  %in% c("long", "short")) %>%
  left_join(select(datasets, seq_run, amplicon, tech, machine), by = "seq_run") %>%
  mutate_at("tech", factor, levels = c("PacBio", "Illumina", "Ion Torrent")) %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(reads = reads / sum(reads))

full_ecdf_short <- full_ecdf %>%
  filter(amplicon == "Short") %>%
  ggplot(aes(length, weight = reads, color = tech, group = tech)) +
  stat_ecdf(geom = "line") +
  scale_color_brewer(type = "qual",
                     name = NULL, palette = "Set2") +
  scale_y_continuous(name = "ECDF") +
  scale_x_continuous(name = NULL) +
  facet_grid( amplicon ~ ., scales = "free_x") +
  theme(
    legend.position = c(1, 0.02),
    legend.justification = c(1, 0),
    legend.background = element_blank(),
    strip.background = element_blank()
  )

full_ecdf_long <- full_ecdf %>%
  filter(amplicon == "Long") %>%
  ggplot(aes(length, weight = reads, color = tech, group = tech)) +
  stat_ecdf(geom = "line") +
  scale_color_brewer(type = "qual",
                     name = NULL, palette = "Set2", direction = -1) +
  scale_y_continuous(name = "ECDF") +
  scale_x_continuous(name = "Length (bp)") +
  facet_grid( amplicon ~ ., scales = "free_x") +
  theme(
    legend.position = c(1, 0.02),
    legend.justification = c(1, 0),
    legend.background = element_blank(),
    strip.background = element_blank()
  )

ggpubr::ggarrange(
  full_dens_short,
  full_ecdf_short,
  full_dens_long,
  full_ecdf_long,
  ncol = 1, heights = c(3, 1.7, 1.2, 2), labels = "auto", vjust = 1
  
)
```

```{r region-length}
regions %>%
  select(Region = region, "Min. length" = min_length, "Max. length" = max_length) %>%
  right_join(
    tibble(Region = c("ITS1", "5_8S", "ITS2", "LSU1", "D1", "LSU2", "D2", "LSU3", "D3", "LSU4")),
    by = "Region"
    ) %>%
  mutate_at("Region", str_replace_all, "_", ".") %>%
  knitr::kable(
    booktabs = TRUE,
    caption = "Minimum and maximum allowed lengths for each extracted region."
  )
```

(ref:region-asv) Plot of total number of ASVs recovered vs. fraction of reads successfully mapped to ASVs for different rDNA regions extracted from long PacBio amplicons using `LSUx`. Some reggions were formed by concatenation of extracted regions, as follows: LSU = LSU1--D1--LSU2--D2--LSU3--D3--LSU4; ITS = ITS1--5.8S--ITS2; 32S = 5.8S--ITS2--LSU; long = ITS--LSU. For this figure, subregions were concatenated prior to generating ASVs with `DADA2`.

```{r regions, fig.cap="(ref:region-asv)"}
readd(region_table) %>%
  dplyr::filter(seq_run == "pb_500") %>%
  ggplot(aes(reads, ASVs, color = length_med, label = region)) +
  geom_point() +
  ggrepel::geom_text_repel() +
  scale_color_gradientn(colors = c("blue", "red", "green1"), limits = c(30, 2000), breaks = c(50, 150, 400, 1000), trans = "log10", name = "median length") +
  xlab("Mapped reads")
```

(ref:region-length) Length distribution for each region extracted from long amplicons.  Filtering limits are shown as dashed vertical lines.

```{r region-lengths, fig.cap = "(ref:region-length)", fig.height = 6}
baseregions <- c("ITS1", "5_8S", "ITS2", "LSU1", "D1", "LSU2", "D2", "LSU3", "D3",
               "LSU4")

region_limits <- dplyr::filter(regions, region %in% baseregions) %>%
  dplyr::mutate_at(
    "region",
    factor,
    levels = baseregions
    ) %>%
  tidyr::pivot_longer(
    cols = c("min_length", "max_length"),
    names_to = "limit",
    names_pattern = "(min|max)_length",
    values_to = "length"
  )
  

readd(reads_table) %>%
  dplyr::filter(region %in% baseregions,
         seq_run == "pb_500") %>%
  dplyr::mutate_at(
    "region",
    factor,
    levels = baseregions
    ) %>%
  ggplot(aes(length, weight = reads)) +
  stat_density(bw = 0.5, color = "#8da0cb", geom = "line") +
  geom_vline(data = region_limits,
             aes(xintercept = length),
             linetype = "dashed", alpha = 0.5) +
  facet_wrap(~region,ncol = 1, strip.position = "right", scales = "free_y") +
  scale_y_continuous(breaks = NULL, labels = NULL, name = "Read density") +
  scale_x_continuous(limits = c(0, 500), name = "Length (bp)")
```

(ref:ITS2-length) Comparison of the length of denoised ITS2 sequences extracted from different length amplicons and sequencing technologies.  *a*) Length distribution.  *b*) Empirical cumulative distribution function.

```{r ITS2-length, fig.cap = "(ref:ITS2-length)", fig.height = 6}
its2 <- readd(reads_table) %>%
  dplyr::left_join(dplyr::select(datasets, seq_run, tech, amplicon), by = "seq_run") %>%
  dplyr::mutate_at("tech", factor, levels = c("PacBio", "Illumina", "Ion Torrent")) %>%
  dplyr::filter(region == "ITS2") %>%
  arrange(tech, amplicon) %>%
  mutate(
    group = paste(tech, "-", amplicon) %>% factor(levels = unique(.))
  ) %>%
  dplyr::group_by(seq_run) %>%
  dplyr::mutate(
    reads = reads / sum(reads)
  )

its2_dens <- its2 %>%
  ggplot(aes(length, weight = reads, color = group, group = group)) +
  stat_density(bw = 0.5, geom = "line", position = "identity") +
  scale_color_brewer(type = "qual", guide = "none", palette = "Set2") +
  scale_y_continuous(name = "Density") +
  scale_x_continuous(name = NULL, labels = NULL, breaks = NULL) +
  ggnomics::facet_nested(rows = vars(tech, amplicon), scales = "free_y",
                         nest_line = TRUE) +
  theme(strip.background = element_blank())

its2_ecdf <- its2 %>%
  mutate(tech = "", amplicon = "") %>%
  ggplot(aes(length, weight = reads, color = group, group = group)) +
  stat_ecdf(geom = "line") +
  scale_color_brewer(type = "qual", name = NULL, palette = "Set2") +
  scale_y_continuous(name = "ECDF") +
  scale_x_continuous(name = "ITS2 Length (bp)") +
  ggnomics::facet_nested(rows = vars(tech, amplicon), scales = "free_y",
                         nest_line = TRUE) +
  theme(
    strip.background = element_blank(),
    legend.position = c(0.98, 0.02),
    legend.justification = c(1, 0)
  )

ggpubr::ggarrange(its2_dens, its2_ecdf, ncol = 1, labels = "auto", heights = c(4, 2))
```

(ref:short-its) Kingdom-level taxonomic composition of ITS2 ASVs <= 140 bp.
Vertical axis shows fraction of total reads in each dataset.

```{r short-its, fig.cap = "(ref:short-its)"}
readd(big_seq_table_ITS2) %>%
  colSums() %>%
  enframe(name = "ITS2", value = "nreads") %>%
  mutate(length = nchar(ITS2)) %>%
  filter(length <= 140) %>%
  mutate_at("ITS2", ~tzara::seqhash(chartr("T", "U", .))) %>%
  semi_join(readd(taxon_reads), ., by = c("label" = "ITS2")) %>%
  # group_by(ITS2) %>%
  # filter(!"Short" %in% amplicon) %>%
  taxon_plot(kingdom, y = reads)
```

(ref:heattree-length-compare) Variation in read abundance and diversity for different amplicons across the taxonomic tree.
Red nodes/edges represent increased read/ASV count for the short amplicon library, while teal nodes/edges represent increased read/ASV count for the long amplicon library.
Values are log_10_ of the ratio of mean values across all datasets (sequencing technology, assignment algorithm, reference database) for each amplicon.
Only nodes with a log read abundance ratio greater than 0.5 (abundance ratio > 3.2) are labeled.
Refer to Figure \@ref(fig:taxa) for complete taxon labeling.

```{r heattree-length-compare, fig.cap = "(ref:heattree-length-compare)"}
taxdata2 <- readd(taxdata)
# taxdata2$data$asv_table <- metacoder::calc_obs_props(taxdata2, "tax_data", cols = asv_cols)
# taxdata2$data$read_table <- metacoder::calc_obs_props(taxdata2, "tax_data", cols = read_cols)
# taxdata2$data$tax_asv <- metacoder::calc_taxon_abund(taxdata2, "asv_table", cols = asv_cols)
# taxdata2$data$tax_read <- metacoder::calc_taxon_abund(taxdata2, "read_table", cols = read_cols)
taxdata2$data$diff_read <- metacoder::compare_groups(
  taxdata2,
  data = "tax_read",
  cols = names(taxdata2$data$tax_read) %>%
    keep(str_detect, "reads_.+_.+_.+_.+"),
  groups = names(taxdata2$data$tax_read) %>%
    keep(str_detect, "reads_.+_.+_.+_.+") %>%
    str_replace("reads_.+_(.+)_.+_.+", "\\1"),
  func = function(abund1, abund2) {
    list(read_ratio = log10(mean(abund1) / mean(abund2)))
  }
  )
taxdata2$data$diff_asv <- metacoder::compare_groups(
  taxdata2,
  data = "tax_asv",
  cols = names(taxdata2$data$tax_asv) %>% keep(startsWith, "ASVs_"),
  groups = names(taxdata2$data$tax_asv) %>%
    keep(startsWith, "ASVs_") %>%
    str_replace("ASVs_.+_(.+)_.+_.+", "\\1"),
  func = function(abund1, abund2) {
    list(asv_ratio = log10(mean(abund1) / mean(abund2)))
  }
)

set.seed(2)
oldtheme <- theme_update(panel.border = element_blank())
taxdata2 %>%
  metacoder::heat_tree(
    layout = "davidson-harel",
    # initial_layout = "reingold-tilford",
    
    node_size = rowMeans(.$data$tax_read[,-1]),
    node_size_range = c(0.002, .035),
    node_size_axis_label = "Read abundance",
    
    node_color = read_ratio,
    node_color_range = metacoder::diverging_palette(),
    node_color_trans = "linear",
    node_color_axis_label = "Read abundance ratio",
    node_color_interval = c(-6, 6),

    edge_size = rowMeans(.$data$tax_asv[,-1]),
    edge_size_range = c(0.001, 0.03),
    edge_size_trans = "linear",
    edge_size_axis_label = "ASV count",

    edge_color = asv_ratio,
    edge_color_range = metacoder::diverging_palette(),
    edge_color_trans = "linear",
    edge_color_axis_label = "ASV count ratio",
    edge_color_interval = c(-3, 3),
    
    node_label = ifelse(
      pmax(abs(.$data$diff_read$read_ratio),
           abs(.$data$diff_asv$asv_ratio)) > 0.5,
      taxon_names,
      ""
    ),
    # aspect_ratio = 3/2,
    node_label_size_range = c(0.010, 0.03)
    # title = unique(paste(.$data$diff_read$treatment_1, "vs.", .$data$diff_read$treatment_2))
  )
theme_set(oldtheme)
```

(ref:ecm) Assignment of ECM status to fungal ASVs using FUNGuild database and taxonomic assignments.
Reads which were not identified to kingdom, or which were identified as a non-Fungi kingdom, are not included.
"unidentified" denotes ASVs which were assigned to kingdom Fungi, but could not be identified to family level or could not be assigned ECM status based on the available identification.
Height of each bar represents the fraction of reads represented by that bar.
Results are shown for different sequencing technologies, amplicons (Long, Short), reference databases (Unite, Warcup, RDP; "All" denotes algorithms which combine results from multiple databases), and taxonomic assignment algorithms.


```{r ECM, fig.cap = "(ref:ecm)"}
  readd(taxon_reads) %>%
  mutate_at("reference", replace_na, "All") %>%
  taxon_plot(ECM, kingdom == "Fungi") +
  theme(legend.position = "bottom", legend.title = element_blank())
```

(ref:ecm-heattree) Variation in read abundance and diversity for different amplicons, for ECM taxa only.
Red nodes/edges represent increased read/ASV count for the short amplicon library, while teal nodes/edges represent increased read/ASV count for the long amplicon library.
Values are log_10_ of the ratio of mean values across all datasets (sequencing technology, assignment algorithm, reference database) for each amplicon.

```{r ecm-heattree, fig.cap = "(ref:ecm-heattree)"}
oldtheme <- theme_update(panel.border = element_blank())
readd(ecm_heattree)
theme_set(oldtheme)
```

(ref:sample-depth) DNA concentrations after extraction (leftmost column) and PCR (second and third columns), and sequencing depth (right three columns) along transects at the two sites Ang and Gan for the years 2015 and 2016.
Sequencing reads which were filtered out during quality control are colored dark grey.
Dotted horizontal line at 100 reads indicates cutoff for inclusion in community analysis.
2016 samples were preserved using two different methods (LifeGuard, Xpedition), while 2015 samples were preserved only using LifeGuard.

```{r sample-depth, fig.cap = "(ref:sample-depth)"}
reads_plot <- readd(qstats_n) %>%
  mutate(file = str_replace(file, ".*/", "") %>%
           str_replace("[.].*", "")) %>%
  tidyr::extract(col = "file", into = c("seq_run", "plate", "row", "col", "read"),
                 regex = "([[:alpha:]]{2}[-_]\\d+)_(\\d+)-([A-H])(\\d+)(_R[12])?[rf]?") %>%
  filter(is.na(step), !is.na(seq_run), read != "_R2" | is.na(read)) %>%
  group_by(seq_run, plate, row, col) %>%
  summarize(raw_reads = sum(nreads)) %>%
  ungroup() %>%
  mutate_at("col", as.integer) %>%
  left_join(
    readd(proto_physeq) %>% {
      mutate(
        sample_data(.),
        reads = otu_table(.) %>% rowSums()
      )
    } %>%
      select(seq_run, plate, row, column, site, year, qual, sample_type, x, buffer, tech, amplicon, reads) %>%
      mutate(row = LETTERS[row]) %>%
      unique(),
    by = c("seq_run", "plate", "row", "col" = "column")
  ) %>%
  filter(tech != "Ion Torrent", !is.na(year), !is.na(seq_run), !is.na(x), !is.na(buffer)) %>%
  complete(nesting(seq_run, tech, amplicon), site, x, nesting(year, buffer)) %>%
  pivot_longer(cols = c("reads", "raw_reads"), names_to = "type", values_to = "reads") %>%
  mutate(
    type = factor(type, levels = c("raw_reads", "reads")),
    "Sample group" = paste(year, buffer) %>%
      ifelse(type == "raw_reads", "Raw", .) %>%
      fct_relevel("Raw")
  ) %>%
  arrange(`Sample group`) %>%
  ggplot(aes(x = x, y = reads, group = `Sample group`, fill = `Sample group`)) +
  geom_col(position = "identity") +
  ggnomics::facet_nested(
    cols = vars(tech, amplicon),
    rows = vars(year, buffer, site),
    nest_line = TRUE,
    resect = unit(1, "mm")
  ) +
  scale_fill_manual(
    values = c(RColorBrewer::brewer.pal(3, "Set2") %>% set_names(c("2015 Xpedition", "2016 LifeGuard", "2016 Xpedition")), Raw = "gray20"),
    breaks = c("2015 Xpedition", "2016 LifeGuard", "2016 Xpedition", "Raw"),
    labels = c("2015 Xpedition", "2016 LifeGuard", "2016 Xpedition", "Filtered")) +
  scale_y_log10(breaks = c(10, 1e3, 1e5),
                labels = c("10", "1k", "100k"), position = "right") +
  xlab("x (m)") +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    panel.spacing = unit(1, "mm"),
    plot.margin = margin(l = 0.5, unit = "mm"),
    axis.text.x = element_text(angle = 90, vjust = 0.5)
  ) +
  geom_hline(yintercept = 100, linetype = 2, alpha = 0.5)

conc_plot <- readd(proto_physeq) %>% 
        sample_data(.) %>%
      select(plate, row, column, site, year, sample_type, x, buffer, amplicon, dna_conc, pcr_conc) %>%
  arrange(plate, row, column, amplicon) %>% 
  unique() %>% 
  mutate_at("dna_conc", as.double) %>%
  pivot_longer(cols = c("dna_conc", "pcr_conc"), names_to = "step", values_to = "conc", names_pattern = "([[:alpha:]]+)_conc") %>%
  filter(!is.na(year)) %>%
  mutate(
    amplicon = ifelse(step == "dna", "", amplicon),
    step = factor(step, levels = c("dna", "pcr"), labels = c("DNA", "PCR product")),
    conc = 1000 * conc,
    "Sample group" = paste(year, buffer)
  ) %>%
  unique() %>%
  complete(nesting(amplicon, step), site, x, nesting(year, buffer, `Sample group`)) %>%
  arrange(`Sample group`) %>%
  ggplot(aes(x = x, y = conc, group = `Sample group`, fill = `Sample group`)) +
  geom_col() +
  ggnomics::facet_nested(
    cols = vars(step, amplicon),
    rows = vars(year, buffer, site),
    nest_line = TRUE,
    resect = unit(1, "mm"),
    switch = "y"
  ) +
  scale_fill_manual(values = RColorBrewer::brewer.pal(3, "Set2") %>% set_names(c("2015 Xpedition", "2016 LifeGuard", "2016 Xpedition")), guide = "none") +
  scale_y_log10(
    breaks = c(10, 1e3, 1e5),
    labels = c("0.1", "1", "100"),
    name = "DNA concentration (ng/µL)"
  ) +
  xlab("x (m)") +
  theme(
    legend.position = "bottom",
    strip.background = element_blank(),
    strip.placement = "outside",
    panel.spacing = unit(1, "mm"),
    plot.margin = margin(r = 0.5, unit = "mm"),
    axis.text.x = element_text(angle = 90, vjust = 0.5)
  )
  
ggpubr::ggarrange(conc_plot, reads_plot, ncol = 2, common.legend = TRUE) +
  theme(panel.spacing = unit(0, "mm"))
```

```{r plate-loading}
readd(proto_physeq) %>% {
  mutate(
    sample_data(.),
    reads = otu_table(.) %>% rowSums()
  )
} %>%
  filter(tech != "Ion Torrent", amplicon == "Short", !is.na(year), !is.na(seq_run), !is.na(x)) %>%
  select(plate, well, tech, reads, year, site, buffer) %>%
  pivot_wider(names_from = "tech", values_from = "reads") %>%
  ggplot(aes(x = PacBio, y = Illumina, color = year)) +
  geom_point()
```


```{r}
physeq <- readd(proto_physeq) %>%
  `sample_data<-`(inset2(
    sample_data(.),
    "qual",
    value = fct_collapse(sample_data(.)$qual, "-" = c("", "*"))
    )) %>%
  subset_samples(!is.na(site)) %>%
  merge_samples(group = glue::glue_data(
    sample_data(.),
    "{year}_{buffer}_{tech}_{amplicon}"
  ))

ranks <- c("root", "kingdom", "phylum", "class", "order", "family", "genus")
physeq <- readd(taxon_reads) %>%
  mutate(root = "Root") %>%
  group_by(label) %>%
  arrange(amplicon, reference, Algorithm, .by_group = TRUE) %>%
  summarize_at(ranks, first) %>%
  left_join(
    tibble(label = taxa_names(physeq)),
    .,
    by = "label"
  ) %>% {
    split(select(., -label), .$label)
  } %>%
  lapply(unlist) %>%
  build_tax_table() %>%
  `tax_table<-`(physeq, .) %>%
  tax_glom(taxrank = "family", NArm = FALSE)
```

(ref:buffer-compare-long) Comparison of read counts by taxonomic groups for different preservation buffers (Xpedition vs. LifeGuard) and sampling year, for long amplicon libraries.

```{r buffer-compare-long, fig.cap = "(ref:buffer-compare-long)"}
taxmap <- metacoder::parse_phyloseq(physeq)
taxmap$data$otu_table <- metacoder::calc_obs_props(taxmap, "otu_table")
taxmap$data$read_count <- metacoder::calc_taxon_abund(taxmap, "otu_table")
taxmap$data$read_diff <- metacoder::compare_groups(
  taxmap,
  "read_count",
  cols = names(taxmap$data$read_count) %>%
    keep(endsWith, "Long"),
  groups = names(taxmap$data$read_count) %>%
    keep(endsWith, "Long") %>%
    str_match("(2015|2016)_(Xpedition|LifeGuard)") %>% {
      paste(.[,3], .[,2])
    },
  func = function(abund1, abund2) {
    list(read_ratio = log10(mean(abund1) / mean(abund2)) %>% ifelse(is.nan(.), 0, .))
  },
  combinations = list(
    c("Xpedition 2016", "Xpedition 2015"),
    c("Xpedition 2016", "LifeGuard 2016"),
    c("Xpedition 2015", "LifeGuard 2016")
  )
)
oldtheme <- theme_update(panel.border = element_blank())
taxa::filter_taxa(
  taxmap,
  taxmap$data$read_count$`2015_Xpedition_PacBio_Long` > 0 |
    taxmap$data$read_count$`2016_Xpedition_PacBio_Long` > 0 |
    taxmap$data$read_count$`2016_LifeGuard_PacBio_Long` > 0,
  drop_obs = TRUE,
  reassign_obs = FALSE
  ) %>%
metacoder::heat_tree_matrix(
  "read_diff",
  node_label = taxon_names,
  node_color = read_ratio,
  node_size = rowMeans(.$data$read_count[-1]),
  node_size_axis_label = "Read fraction",
  node_color_range = metacoder::diverging_palette(),
  node_color_axis_label = "Log10 Read Ratio",
  node_color_interval = c(-3, 3),
  node_color_trans = "linear",
  edge_size = rowMeans(.$data$read_count[-1]),
  edge_size_range = c(0, 0.03),
  edge_size_trans = "linear",
  edge_size_axis_label = "ASV fraction",
  node_size_range = c(0, 0.03),
  node_label_size_range = c(0.005, 0.03),
  layout = "davidson-harel",
  initial_layout = "reingold-tilford",
  output_file = here("temp/compare_long.pdf")
)
theme_set(oldtheme)

```

(ref:buffer-compare-short) Comparison of read counts by taxonomic groups for different preservation buffers (Xpedition vs. LifeGuard) and sampling year, for long amplicon libraries.

```{r buffer-compare-short, fig.cap = "(ref:buffer-compare-short)"}
taxmap$data$read_diff <- metacoder::compare_groups(
  taxmap,
  "read_count",
  cols = names(taxmap$data$read_count) %>%
    keep(endsWith, "Short"),
  groups = names(taxmap$data$read_count) %>%
    keep(endsWith, "Short") %>%
    str_match("(2015|2016)_(Xpedition|LifeGuard)") %>% {
      paste(.[,3], .[,2])
    },
  func = function(abund1, abund2) {
    list(read_ratio = log10(mean(abund1) / mean(abund2)) %>% ifelse(is.nan(.), 0, .))
  },
  combinations = list(
    c("Xpedition 2016", "Xpedition 2015"),
    c("Xpedition 2016", "LifeGuard 2016"),
    c("Xpedition 2015", "LifeGuard 2016")
  )
)
taxa::filter_taxa(
  taxmap,
  taxmap$data$read_count %>% select(ends_with("Short")) %>% rowSums() > 0,
  drop_obs = TRUE,
  reassign_obs = FALSE
  ) %>%
metacoder::heat_tree_matrix(
  "read_diff",
  node_label = taxon_names,
  node_color = read_ratio,
  node_size = rowMeans(.$data$read_count[-1]),
  node_size_axis_label = "Read fraction",
  node_color_range = metacoder::diverging_palette(),
  node_color_axis_label = "Log10 Read Ratio",
  node_color_interval = c(-3, 3),
  node_color_trans = "linear",
  edge_size = rowMeans(.$data$read_count[-1]),
  edge_size_range = c(0, 0.03),
  edge_size_trans = "linear",
  edge_size_axis_label = "ASV fraction",
  node_size_range = c(0, 0.03),
  node_label_size_range = c(0.005, 0.03),
  layout = "davidson-harel",
  initial_layout = "reingold-tilford",
  output_file = here("temp/compare_short.pdf")
)

```